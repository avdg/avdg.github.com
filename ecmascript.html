<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>ES Grammar parsing rules</title>
<style>@media print {
    .no-print {
        display: none !important;
    }
    .multi-col {
        -moz-column-count: 3;
        -moz-column-gap: 5px;
        -webkit-column-count: 3;
        -webkit-column-gap: 5px;
        column-count: 3;
        column-gap: 5px;
        column-fill: balance;
    }
}

@page {
    margin: 6mm;
}

@media screen and (min-width:1200px) {
    .multi-col {
        -moz-column-count: 4;
        -moz-column-gap: 10px;
        -webkit-column-count: 4;
        -webkit-column-gap: 10px;
        column-count: 4;
        column-gap: 10px;
        column-fill: balance;
    }
}

@media screen and (min-width:900px) and (max-width:1199) {
    .multi-col {
        -moz-column-count: 3;
        -moz-column-gap: 10px;
        -webkit-column-count: 3;
        -webkit-column-gap: 10px;
        column-count: 3;
        column-gap: 10px;
        column-fill: balance;
    }
}

@media screen and (min-width:600px) and (max-width:899px) {
    .multi-col {
        -moz-column-count: 2;
        -moz-column-gap: 10px;
        -webkit-column-count: 2;
        -webkit-column-gap: 10px;
        column-count: 2;
        column-gap: 10px;
        column-fill: balance;
    }
}

@media screen and (max-width:300px) {
    .multi-col {
        -moz-column-count: 1;
        -moz-column-gap: 10px;
        -webkit-column-count: 1;
        -webkit-column-gap: 10px;
        column-count: 1;
        column-gap: 10px;
        column-fill: balance;
    }
}

div {
    margin: 0px;
    padding: 0px;
}

p {
    break-after: always;
    margin: 2px 0;
    line-height: 100%;
}

p + p {
    margin-top: 0px;
}

i {
    color: #888;
}

code pre {
    font-size: 75%;
    margin: 2px 0;
    white-space: pre-wrap;
}

code pre::first-line {
    font-weight: bold;
}

input[type='checkbox'] {
    width: 20px;
    height: 20px;
    border-radius: 4px;
}

#selector {
    border: 1px solid #000000;
    border-radius: 5px;
    background: rgba(200,200,200, .5);
}

#selector h2 {
    color: #880088;
}

#grammar {
    line-break: strict;
    word-break: break-all;
}

.definitions b {
    font-size: 80%;
    line-heigth: 90%;
}

.definitions p {
    font-size: 60%;
}

.sec-lexical-grammar b {
    color: #00cc00;
}

.sec-expressions b {
    color: #cc0000;
}

.sec-statements b {
    color: #0000cc;
}

.sec-functions-and-classes b {
    color: #888800;
}

.sec-scripts-and-modules b {
    color: #880088;
}

.sec-number-conversions b {
    color: #008888;
}

.sec-universal-resource-identifier-character-classes b {
    color: #4444cc;
}

.sec-regular-expressions b {
    color: #44cc44;
}
</style>
<link rel="icon" href="es-favicon.ico" type="image/x-icon"/>
</head><body>
<div id="selector" class="multi-col no-print">
<h2>Ecmascript language grammar as of 1/4/2018</h2>
<input type="checkbox" id="select-lexical-grammar" checked><a href="#">Lexical grammar</a><br>
<input type="checkbox" id="select-expressions" checked><a href="#">Expressions</a><br>
<input type="checkbox" id="select-statements" checked><a href="#">Statements</a><br>
<input type="checkbox" id="select-functions-and-classes" checked><a href="#">Functions and Classes</a><br>
<input type="checkbox" id="select-scripts-and-modules" checked><a href="#">Scripts and Modules</a><br>
<input type="checkbox" id="select-number-conversions" checked><a href="#">Number conversions</a><br>
<input type="checkbox" id="select-universal-resource-identifier-character-classes" checked><a href="#">Universal resource identifier character classes</a><br>
<input type="checkbox" id="select-regular-expressions" checked><a href="#">Regular expressions</a><br>
</div>
<div class="multi-col" id="grammar">
<div class="sec-lexical-grammar definitions"><b>SourceCharacter</b><br><code><pre>SourceCharacter ::<br>&emsp;&gt; any Unicode code point</pre></code></div><div class="sec-lexical-grammar definitions"><b>InputElementDiv</b><br><code><pre>InputElementDiv ::<br>&emsp;WhiteSpace<br>&emsp;LineTerminator<br>&emsp;Comment<br>&emsp;CommonToken<br>&emsp;DivPunctuator<br>&emsp;RightBracePunctuator</pre></code></div><div class="sec-lexical-grammar definitions"><b>InputElementRegExp</b><br><code><pre>InputElementRegExp ::<br>&emsp;WhiteSpace<br>&emsp;LineTerminator<br>&emsp;Comment<br>&emsp;CommonToken<br>&emsp;RightBracePunctuator<br>&emsp;RegularExpressionLiteral</pre></code></div><div class="sec-lexical-grammar definitions"><b>InputElementRegExpOrTemplateTail</b><br><code><pre>InputElementRegExpOrTemplateTail ::<br>&emsp;WhiteSpace<br>&emsp;LineTerminator<br>&emsp;Comment<br>&emsp;CommonToken<br>&emsp;RegularExpressionLiteral<br>&emsp;TemplateSubstitutionTail</pre></code></div><div class="sec-lexical-grammar definitions"><b>InputElementTemplateTail</b><br><code><pre>InputElementTemplateTail ::<br>&emsp;WhiteSpace<br>&emsp;LineTerminator<br>&emsp;Comment<br>&emsp;CommonToken<br>&emsp;DivPunctuator<br>&emsp;TemplateSubstitutionTail</pre></code></div><div class="sec-lexical-grammar definitions"><b>WhiteSpace</b><br><code><pre>WhiteSpace :: one of<br>&emsp;&lt;TAB&gt; &lt;VT&gt; &lt;FF&gt; &lt;SP&gt; &lt;NBSP&gt; &lt;ZWNBSP&gt; &lt;USP&gt;</pre></code></div><div class="sec-lexical-grammar definitions"><b>LineTerminator</b><br><code><pre>LineTerminator :: one of<br>&emsp;&lt;LF&gt; &lt;CR&gt; &lt;LS&gt; &lt;PS&gt;</pre></code></div><div class="sec-lexical-grammar definitions"><b>LineTerminatorSequence</b><br><code><pre>LineTerminatorSequence ::<br>&emsp;&lt;LF&gt;<br>&emsp;&lt;CR&gt; [lookahead != &lt;LF&gt; ]<br>&emsp;&lt;LS&gt;<br>&emsp;&lt;PS&gt;<br>&emsp;&lt;CR&gt; &lt;LF&gt;</pre></code></div><div class="sec-lexical-grammar definitions"><b>Comment</b><br><code><pre>Comment ::<br>&emsp;MultiLineComment<br>&emsp;SingleLineComment</pre></code><code><pre>Comment ::<br>&emsp;MultiLineComment<br>&emsp;SingleLineComment<br>&emsp;SingleLineHTMLOpenComment<br>&emsp;SingleLineHTMLCloseComment<br>&emsp;SingleLineDelimitedComment</pre></code></div><div class="sec-lexical-grammar definitions"><b>MultiLineComment</b><br><code><pre>MultiLineComment ::<br>&emsp;`/*` <i>MultiLineCommentChars?</i> `*/`</pre></code><code><pre>MultiLineComment ::<br>&emsp;`/*` <i>FirstCommentLine?</i> LineTerminator <i>MultiLineCommentChars?</i> `*/` <i>HTMLCloseComment?</i></pre></code></div><div class="sec-lexical-grammar definitions"><b>MultiLineCommentChars</b><br><code><pre>MultiLineCommentChars ::<br>&emsp;MultiLineNotAsteriskChar <i>MultiLineCommentChars?</i><br>&emsp;`*` <i>PostAsteriskCommentChars?</i></pre></code></div><div class="sec-lexical-grammar definitions"><b>PostAsteriskCommentChars</b><br><code><pre>PostAsteriskCommentChars ::<br>&emsp;MultiLineNotForwardSlashOrAsteriskChar <i>MultiLineCommentChars?</i><br>&emsp;`*` <i>PostAsteriskCommentChars?</i></pre></code></div><div class="sec-lexical-grammar definitions"><b>MultiLineNotAsteriskChar</b><br><code><pre>MultiLineNotAsteriskChar ::<br>&emsp;SourceCharacter but not `*`</pre></code></div><div class="sec-lexical-grammar definitions"><b>MultiLineNotForwardSlashOrAsteriskChar</b><br><code><pre>MultiLineNotForwardSlashOrAsteriskChar ::<br>&emsp;SourceCharacter but not one of `/` or `*`</pre></code></div><div class="sec-lexical-grammar definitions"><b>SingleLineComment</b><br><code><pre>SingleLineComment ::<br>&emsp;`//` <i>SingleLineCommentChars?</i></pre></code></div><div class="sec-lexical-grammar definitions"><b>SingleLineCommentChars</b><br><code><pre>SingleLineCommentChars ::<br>&emsp;SingleLineCommentChar <i>SingleLineCommentChars?</i></pre></code></div><div class="sec-lexical-grammar definitions"><b>SingleLineCommentChar</b><br><code><pre>SingleLineCommentChar ::<br>&emsp;SourceCharacter but not LineTerminator</pre></code></div><div class="sec-lexical-grammar definitions"><b>CommonToken</b><br><code><pre>CommonToken ::<br>&emsp;IdentifierName<br>&emsp;Punctuator<br>&emsp;NumericLiteral<br>&emsp;StringLiteral<br>&emsp;Template</pre></code></div><div class="sec-lexical-grammar definitions"><b>IdentifierName</b><br><code><pre>IdentifierName ::<br>&emsp;IdentifierStart<br>&emsp;IdentifierName IdentifierPart</pre></code></div><div class="sec-lexical-grammar definitions"><b>IdentifierStart</b><br><code><pre>IdentifierStart ::<br>&emsp;UnicodeIDStart<br>&emsp;`$`<br>&emsp;`_`<br>&emsp;`\` UnicodeEscapeSequence</pre></code></div><div class="sec-lexical-grammar definitions"><b>IdentifierPart</b><br><code><pre>IdentifierPart ::<br>&emsp;UnicodeIDContinue<br>&emsp;`$`<br>&emsp;`\` UnicodeEscapeSequence<br>&emsp;&lt;ZWNJ&gt;<br>&emsp;&lt;ZWJ&gt;</pre></code></div><div class="sec-lexical-grammar definitions"><b>UnicodeIDStart</b><br><code><pre>UnicodeIDStart ::<br>&emsp;&gt; any Unicode code point with the Unicode property &ldquo;ID_Start&rdquo;</pre></code></div><div class="sec-lexical-grammar definitions"><b>UnicodeIDContinue</b><br><code><pre>UnicodeIDContinue ::<br>&emsp;&gt; any Unicode code point with the Unicode property &ldquo;ID_Continue&rdquo;</pre></code></div><div class="sec-lexical-grammar definitions"><b>ReservedWord</b><br><code><pre>ReservedWord ::<br>&emsp;Keyword<br>&emsp;FutureReservedWord<br>&emsp;NullLiteral<br>&emsp;BooleanLiteral</pre></code></div><div class="sec-lexical-grammar definitions"><b>Keyword</b><br><code><pre>Keyword :: one of<br>&emsp;`await`<br>&emsp;`break`<br>&emsp;`case` `catch` `class` `const` `continue`<br>&emsp;`debugger` `default` `delete` `do`<br>&emsp;`else` `export` `extends`<br>&emsp;`finally` `for` `function`<br>&emsp;`if` `import` `in` `instanceof`<br>&emsp;`new`<br>&emsp;`return`<br>&emsp;`super` `switch`<br>&emsp;`this` `throw` `try` `typeof`<br>&emsp;`var` `void`<br>&emsp;`while` `with`<br>&emsp;`yield`</pre></code></div><div class="sec-lexical-grammar definitions"><b>FutureReservedWord</b><br><code><pre>FutureReservedWord ::<br>&emsp;`enum`</pre></code><p>The following tokens are also considered to be |FutureReservedWord|s when parsing strict mode code:</p><p><emu-t>implements</emu-t> &nbsp;<emu-t>package</emu-t> &nbsp;<emu-t>protected</emu-t><br>
      <emu-t>interface</emu-t> &nbsp;<emu-t>private</emu-t> &nbsp;<emu-t>public</emu-t>
    </p></div><div class="sec-lexical-grammar definitions"><b>Punctuator</b><br><code><pre>Punctuator :: one of<br>&emsp;`{` `(` `)` `[` `]`<br>&emsp;`.` `...` `;` `,`<br>&emsp;`&lt;` `&gt;` `&lt;=` `&gt;=`<br>&emsp;`==` `!=` `===` `!==`<br>&emsp;`+` `-` `*` `%` `**`<br>&emsp;`++` `--`<br>&emsp;`&lt;&lt;` `&gt;&gt;` `&gt;&gt;&gt;`<br>&emsp;`&amp;` `|` `^`<br>&emsp;`!` `~`<br>&emsp;`&amp;&amp;` `||`<br>&emsp;`?` `:`<br>&emsp;`=` `+=` `-=` `*=` `%=` `**=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `|=` `^=`<br>&emsp;`=&gt;`</pre></code></div><div class="sec-lexical-grammar definitions"><b>DivPunctuator</b><br><code><pre>DivPunctuator :: one of<br>&emsp;`/` `/=`</pre></code></div><div class="sec-lexical-grammar definitions"><b>RightBracePunctuator</b><br><code><pre>RightBracePunctuator ::<br>&emsp;`}`</pre></code></div><div class="sec-lexical-grammar definitions"><b>NullLiteral</b><br><code><pre>NullLiteral ::<br>&emsp;`null`</pre></code></div><div class="sec-lexical-grammar definitions"><b>BooleanLiteral</b><br><code><pre>BooleanLiteral :: one of<br>&emsp;`true` `false`</pre></code></div><div class="sec-lexical-grammar definitions"><b>NumericLiteral</b><br><code><pre>NumericLiteral ::<br>&emsp;DecimalLiteral<br>&emsp;BinaryIntegerLiteral<br>&emsp;OctalIntegerLiteral<br>&emsp;HexIntegerLiteral</pre></code><code><pre>NumericLiteral ::<br>&emsp;DecimalLiteral<br>&emsp;BinaryIntegerLiteral<br>&emsp;OctalIntegerLiteral<br>&emsp;HexIntegerLiteral<br>&emsp;LegacyOctalIntegerLiteral</pre></code></div><div class="sec-lexical-grammar definitions"><b>DecimalLiteral</b><br><code><pre>DecimalLiteral ::<br>&emsp;DecimalIntegerLiteral `.` <i>DecimalDigits?</i> <i>ExponentPart?</i><br>&emsp;`.` DecimalDigits <i>ExponentPart?</i><br>&emsp;DecimalIntegerLiteral <i>ExponentPart?</i></pre></code></div><div class="sec-lexical-grammar definitions"><b>DecimalIntegerLiteral</b><br><code><pre>DecimalIntegerLiteral ::<br>&emsp;`0`<br>&emsp;NonZeroDigit <i>DecimalDigits?</i></pre></code><code><pre>DecimalIntegerLiteral ::<br>&emsp;`0`<br>&emsp;NonZeroDigit <i>DecimalDigits?</i><br>&emsp;NonOctalDecimalIntegerLiteral</pre></code></div><div class="sec-lexical-grammar definitions"><b>DecimalDigits</b><br><code><pre>DecimalDigits ::<br>&emsp;DecimalDigit<br>&emsp;DecimalDigits DecimalDigit</pre></code></div><div class="sec-lexical-grammar definitions"><b>DecimalDigit</b><br><code><pre>DecimalDigit :: one of<br>&emsp;`0` `1` `2` `3` `4` `5` `6` `7` `8` `9`</pre></code></div><div class="sec-lexical-grammar definitions"><b>NonZeroDigit</b><br><code><pre>NonZeroDigit :: one of<br>&emsp;`1` `2` `3` `4` `5` `6` `7` `8` `9`</pre></code></div><div class="sec-lexical-grammar definitions"><b>ExponentPart</b><br><code><pre>ExponentPart ::<br>&emsp;ExponentIndicator SignedInteger</pre></code></div><div class="sec-lexical-grammar definitions"><b>ExponentIndicator</b><br><code><pre>ExponentIndicator :: one of<br>&emsp;`e` `E`</pre></code></div><div class="sec-lexical-grammar definitions"><b>SignedInteger</b><br><code><pre>SignedInteger ::<br>&emsp;DecimalDigits<br>&emsp;`+` DecimalDigits<br>&emsp;`-` DecimalDigits</pre></code></div><div class="sec-lexical-grammar definitions"><b>BinaryIntegerLiteral</b><br><code><pre>BinaryIntegerLiteral ::<br>&emsp;`0b` BinaryDigits<br>&emsp;`0B` BinaryDigits</pre></code></div><div class="sec-lexical-grammar definitions"><b>BinaryDigits</b><br><code><pre>BinaryDigits ::<br>&emsp;BinaryDigit<br>&emsp;BinaryDigits BinaryDigit</pre></code></div><div class="sec-lexical-grammar definitions"><b>BinaryDigit</b><br><code><pre>BinaryDigit :: one of<br>&emsp;`0` `1`</pre></code></div><div class="sec-lexical-grammar definitions"><b>OctalIntegerLiteral</b><br><code><pre>OctalIntegerLiteral ::<br>&emsp;`0o` OctalDigits<br>&emsp;`0O` OctalDigits</pre></code></div><div class="sec-lexical-grammar definitions"><b>OctalDigits</b><br><code><pre>OctalDigits ::<br>&emsp;OctalDigit<br>&emsp;OctalDigits OctalDigit</pre></code></div><div class="sec-lexical-grammar definitions"><b>OctalDigit</b><br><code><pre>OctalDigit :: one of<br>&emsp;`0` `1` `2` `3` `4` `5` `6` `7`</pre></code></div><div class="sec-lexical-grammar definitions"><b>HexIntegerLiteral</b><br><code><pre>HexIntegerLiteral ::<br>&emsp;`0x` HexDigits<br>&emsp;`0X` HexDigits</pre></code></div><div class="sec-lexical-grammar definitions"><b>HexDigits</b><br><code><pre>HexDigits ::<br>&emsp;HexDigit<br>&emsp;HexDigits HexDigit</pre></code></div><div class="sec-lexical-grammar definitions"><b>HexDigit</b><br><code><pre>HexDigit :: one of<br>&emsp;`0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`</pre></code></div><div class="sec-lexical-grammar definitions"><b>StringLiteral</b><br><code><pre>StringLiteral ::<br>&emsp;`"` <i>DoubleStringCharacters?</i> `"`<br>&emsp;`'` <i>SingleStringCharacters?</i> `'`</pre></code></div><div class="sec-lexical-grammar definitions"><b>DoubleStringCharacters</b><br><code><pre>DoubleStringCharacters ::<br>&emsp;DoubleStringCharacter <i>DoubleStringCharacters?</i></pre></code></div><div class="sec-lexical-grammar definitions"><b>SingleStringCharacters</b><br><code><pre>SingleStringCharacters ::<br>&emsp;SingleStringCharacter <i>SingleStringCharacters?</i></pre></code></div><div class="sec-lexical-grammar definitions"><b>DoubleStringCharacter</b><br><code><pre>DoubleStringCharacter ::<br>&emsp;SourceCharacter but not one of `"` or `\` or LineTerminator<br>&emsp;`\` EscapeSequence<br>&emsp;LineContinuation</pre></code><code><pre>DoubleStringCharacter ::<br>&emsp;SourceCharacter but not one of `"` or `\` or U+0000 through U+001F<br>&emsp;`\` EscapeSequence</pre></code></div><div class="sec-lexical-grammar definitions"><b>SingleStringCharacter</b><br><code><pre>SingleStringCharacter ::<br>&emsp;SourceCharacter but not one of `'` or `\` or LineTerminator<br>&emsp;`\` EscapeSequence<br>&emsp;LineContinuation</pre></code></div><div class="sec-lexical-grammar definitions"><b>LineContinuation</b><br><code><pre>LineContinuation ::<br>&emsp;`\` LineTerminatorSequence</pre></code></div><div class="sec-lexical-grammar definitions"><b>EscapeSequence</b><br><code><pre>EscapeSequence ::<br>&emsp;CharacterEscapeSequence<br>&emsp;`0` [lookahead &lt;! DecimalDigit]<br>&emsp;HexEscapeSequence<br>&emsp;UnicodeEscapeSequence</pre></code><code><pre>EscapeSequence ::<br>&emsp;CharacterEscapeSequence<br>&emsp;LegacyOctalEscapeSequence<br>&emsp;HexEscapeSequence<br>&emsp;UnicodeEscapeSequence</pre></code></div><div class="sec-lexical-grammar definitions"><b>CharacterEscapeSequence</b><br><code><pre>CharacterEscapeSequence ::<br>&emsp;SingleEscapeCharacter<br>&emsp;NonEscapeCharacter</pre></code></div><div class="sec-lexical-grammar definitions"><b>SingleEscapeCharacter</b><br><code><pre>SingleEscapeCharacter :: one of<br>&emsp;`'` `"` `\` `b` `f` `n` `r` `t` `v`</pre></code></div><div class="sec-lexical-grammar definitions"><b>NonEscapeCharacter</b><br><code><pre>NonEscapeCharacter ::<br>&emsp;SourceCharacter but not one of EscapeCharacter or LineTerminator</pre></code></div><div class="sec-lexical-grammar definitions"><b>EscapeCharacter</b><br><code><pre>EscapeCharacter :: one of<br>&emsp;`'` `"` `\` `b` `f` `n` `r` `t` `v`</pre></code></div><div class="sec-lexical-grammar definitions"><b>HexEscapeSequence</b><br><code><pre>HexEscapeSequence ::<br>&emsp;`x` HexDigit HexDigit</pre></code></div><div class="sec-lexical-grammar definitions"><b>UnicodeEscapeSequence</b><br><code><pre>UnicodeEscapeSequence ::<br>&emsp;`u` Hex4Digits<br>&emsp;`u{` CodePoint `}`</pre></code></div><div class="sec-lexical-grammar definitions"><b>Hex4Digits</b><br><code><pre>Hex4Digits ::<br>&emsp;HexDigit HexDigit HexDigit HexDigit</pre></code></div><div class="sec-lexical-grammar definitions"><b>RegularExpressionLiteral</b><br><code><pre>RegularExpressionLiteral ::<br>&emsp;`/` RegularExpressionBody `/` RegularExpressionFlags</pre></code></div><div class="sec-lexical-grammar definitions"><b>RegularExpressionBody</b><br><code><pre>RegularExpressionBody ::<br>&emsp;RegularExpressionFirstChar RegularExpressionChars</pre></code></div><div class="sec-lexical-grammar definitions"><b>RegularExpressionChars</b><br><code><pre>RegularExpressionChars ::<br>&emsp;[empty]<br>&emsp;RegularExpressionChars RegularExpressionChar</pre></code></div><div class="sec-lexical-grammar definitions"><b>RegularExpressionFirstChar</b><br><code><pre>RegularExpressionFirstChar ::<br>&emsp;RegularExpressionNonTerminator but not one of `*` or `\` or `/` or `[`<br>&emsp;RegularExpressionBackslashSequence<br>&emsp;RegularExpressionClass</pre></code></div><div class="sec-lexical-grammar definitions"><b>RegularExpressionChar</b><br><code><pre>RegularExpressionChar ::<br>&emsp;RegularExpressionNonTerminator but not one of `\` or `/` or `[`<br>&emsp;RegularExpressionBackslashSequence<br>&emsp;RegularExpressionClass</pre></code></div><div class="sec-lexical-grammar definitions"><b>RegularExpressionBackslashSequence</b><br><code><pre>RegularExpressionBackslashSequence ::<br>&emsp;`\` RegularExpressionNonTerminator</pre></code></div><div class="sec-lexical-grammar definitions"><b>RegularExpressionNonTerminator</b><br><code><pre>RegularExpressionNonTerminator ::<br>&emsp;SourceCharacter but not LineTerminator</pre></code></div><div class="sec-lexical-grammar definitions"><b>RegularExpressionClass</b><br><code><pre>RegularExpressionClass ::<br>&emsp;`[` RegularExpressionClassChars `]`</pre></code></div><div class="sec-lexical-grammar definitions"><b>RegularExpressionClassChars</b><br><code><pre>RegularExpressionClassChars ::<br>&emsp;[empty]<br>&emsp;RegularExpressionClassChars RegularExpressionClassChar</pre></code></div><div class="sec-lexical-grammar definitions"><b>RegularExpressionClassChar</b><br><code><pre>RegularExpressionClassChar ::<br>&emsp;RegularExpressionNonTerminator but not one of `]` or `\`<br>&emsp;RegularExpressionBackslashSequence</pre></code></div><div class="sec-lexical-grammar definitions"><b>RegularExpressionFlags</b><br><code><pre>RegularExpressionFlags ::<br>&emsp;[empty]<br>&emsp;RegularExpressionFlags IdentifierPart</pre></code></div><div class="sec-lexical-grammar definitions"><b>Template</b><br><code><pre>Template ::<br>&emsp;NoSubstitutionTemplate<br>&emsp;TemplateHead</pre></code></div><div class="sec-lexical-grammar definitions"><b>NoSubstitutionTemplate</b><br><code><pre>NoSubstitutionTemplate ::<br>&emsp;` `` <i>TemplateCharacters?</i> ` ``</pre></code></div><div class="sec-lexical-grammar definitions"><b>TemplateHead</b><br><code><pre>TemplateHead ::<br>&emsp;` `` <i>TemplateCharacters?</i> `${`</pre></code></div><div class="sec-lexical-grammar definitions"><b>TemplateSubstitutionTail</b><br><code><pre>TemplateSubstitutionTail ::<br>&emsp;TemplateMiddle<br>&emsp;TemplateTail</pre></code></div><div class="sec-lexical-grammar definitions"><b>TemplateMiddle</b><br><code><pre>TemplateMiddle ::<br>&emsp;`}` <i>TemplateCharacters?</i> `${`</pre></code></div><div class="sec-lexical-grammar definitions"><b>TemplateTail</b><br><code><pre>TemplateTail ::<br>&emsp;`}` <i>TemplateCharacters?</i> ` ``</pre></code></div><div class="sec-lexical-grammar definitions"><b>TemplateCharacters</b><br><code><pre>TemplateCharacters ::<br>&emsp;TemplateCharacter <i>TemplateCharacters?</i></pre></code></div><div class="sec-lexical-grammar definitions"><b>TemplateCharacter</b><br><code><pre>TemplateCharacter ::<br>&emsp;`$` [lookahead != `{` ]<br>&emsp;`\` EscapeSequence<br>&emsp;`\` NotEscapeSequence<br>&emsp;LineContinuation<br>&emsp;LineTerminatorSequence<br>&emsp;SourceCharacter but not one of ` `` or `\` or `$` or LineTerminator</pre></code></div><div class="sec-expressions definitions"><b>IdentifierReference</b><br><code><pre>IdentifierReference[Yield, Await] :<br>&emsp;Identifier<br>&emsp;[~Yield] `yield`<br>&emsp;[~Await] `await`</pre></code><code><pre>IdentifierReference : `yield`</pre></code><code><pre>IdentifierReference : `await`</pre></code><code><pre>IdentifierReference[Yield, Await] : Identifier</pre></code></div><div class="sec-expressions definitions"><b>BindingIdentifier</b><br><code><pre>BindingIdentifier[Yield, Await] :<br>&emsp;Identifier<br>&emsp;`yield`<br>&emsp;`await`</pre></code><code><pre>BindingIdentifier : `yield`</pre></code><code><pre>BindingIdentifier : `await`</pre></code><code><pre>BindingIdentifier[Yield, Await] : Identifier</pre></code><code><pre>BindingIdentifier :<br>&emsp;Identifier<br>&emsp;`yield`<br>&emsp;`await`</pre></code></div><div class="sec-expressions definitions"><b>Identifier</b><br><code><pre>Identifier ::<br>&emsp;IdentifierName but not ReservedWord</pre></code><code><pre>Identifier[Yield, Await] :<br>&emsp;Identifier<br>&emsp;`yield`<br>&emsp;`await`</pre></code></div><div class="sec-expressions definitions"><b>AsyncArrowBindingIdentifier</b><br><code><pre>AsyncArrowBindingIdentifier[Yield] :<br>&emsp;BindingIdentifier[?Yield, +Await]</pre></code><code><pre>AsyncArrowBindingIdentifier : BindingIdentifier</pre></code><code><pre>AsyncArrowBindingIdentifier[Yield] : BindingIdentifier[?Yield, +Await]</pre></code></div><div class="sec-expressions definitions"><b>LabelIdentifier</b><br><code><pre>LabelIdentifier[Yield, Await] :<br>&emsp;Identifier<br>&emsp;[~Yield] `yield`<br>&emsp;[~Await] `await`</pre></code><code><pre>LabelIdentifier : `yield`</pre></code><code><pre>LabelIdentifier : `await`</pre></code><code><pre>LabelIdentifier[Yield, Await] : Identifier</pre></code></div><div class="sec-expressions definitions"><b>PrimaryExpression</b><br><code><pre>PrimaryExpression[Yield, Await] :<br>&emsp;`this`<br>&emsp;IdentifierReference[?Yield, ?Await]<br>&emsp;Literal<br>&emsp;ArrayLiteral[?Yield, ?Await]<br>&emsp;ObjectLiteral[?Yield, ?Await]<br>&emsp;FunctionExpression<br>&emsp;ClassExpression[?Yield, ?Await]<br>&emsp;GeneratorExpression<br>&emsp;AsyncFunctionExpression<br>&emsp;AsyncGeneratorExpression<br>&emsp;RegularExpressionLiteral<br>&emsp;TemplateLiteral[?Yield, ?Await, ~Tagged]<br>&emsp;CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover</pre></code><code><pre>PrimaryExpression :<br>&emsp;`this`<br>&emsp;IdentifierReference<br>&emsp;Literal<br>&emsp;ArrayLiteral<br>&emsp;ObjectLiteral<br>&emsp;RegularExpressionLiteral<br>&emsp;TemplateLiteral</pre></code><code><pre>PrimaryExpression :<br>&emsp;`this`<br>&emsp;Literal<br>&emsp;ArrayLiteral<br>&emsp;ObjectLiteral<br>&emsp;FunctionExpression<br>&emsp;ClassExpression<br>&emsp;GeneratorExpression<br>&emsp;AsyncFunctionExpression<br>&emsp;AsyncGeneratorExpression<br>&emsp;RegularExpressionLiteral<br>&emsp;TemplateLiteral<br>&emsp;CoverParenthesizedExpressionAndArrowParameterList</pre></code><code><pre>PrimaryExpression :<br>&emsp;`this`<br>&emsp;Literal<br>&emsp;ArrayLiteral<br>&emsp;ObjectLiteral<br>&emsp;FunctionExpression<br>&emsp;ClassExpression<br>&emsp;GeneratorExpression<br>&emsp;AsyncFunctionExpression<br>&emsp;AsyncGeneratorExpression<br>&emsp;RegularExpressionLiteral<br>&emsp;TemplateLiteral</pre></code><code><pre>PrimaryExpression :<br>&emsp;`this`<br>&emsp;IdentifierReference<br>&emsp;Literal<br>&emsp;ArrayLiteral<br>&emsp;ObjectLiteral<br>&emsp;FunctionExpression<br>&emsp;ClassExpression<br>&emsp;GeneratorExpression<br>&emsp;AsyncFunctionExpression<br>&emsp;AsyncGeneratorExpression<br>&emsp;RegularExpressionLiteral<br>&emsp;TemplateLiteral</pre></code></div><div class="sec-expressions definitions"><b>CoverParenthesizedExpressionAndArrowParameterList</b><br><code><pre>CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :<br>&emsp;`(` Expression[+In, ?Yield, ?Await] `)`<br>&emsp;`(` Expression[+In, ?Yield, ?Await] `,` `)`<br>&emsp;`(` `)`<br>&emsp;`(` `...` BindingIdentifier[?Yield, ?Await] `)`<br>&emsp;`(` `...` BindingPattern[?Yield, ?Await] `)`<br>&emsp;`(` Expression[+In, ?Yield, ?Await] `,` `...` BindingIdentifier[?Yield, ?Await] `)`<br>&emsp;`(` Expression[+In, ?Yield, ?Await] `,` `...` BindingPattern[?Yield, ?Await] `)`</pre></code><code><pre>CoverParenthesizedExpressionAndArrowParameterList :<br>&emsp;`(` Expression `)`<br>&emsp;`(` `)`<br>&emsp;`(` `...` BindingIdentifier `)`<br>&emsp;`(` `...` BindingPattern `)`<br>&emsp;`(` Expression `,` `...` BindingIdentifier `)`<br>&emsp;`(` Expression `,` `...` BindingPattern `)`</pre></code><p>When processing an instance of the production |PrimaryExpression| the interpretation of |CoverParenthesizedExpressionAndArrowParameterList| is refined using the following grammar:</p></div><div class="sec-expressions definitions"><b>ParenthesizedExpression</b><br><code><pre>ParenthesizedExpression[Yield, Await] :<br>&emsp;`(` Expression[+In, ?Yield, ?Await] `)`</pre></code><code><pre>ParenthesizedExpression :<br>&emsp;`(` Expression `)`</pre></code></div><div class="sec-expressions definitions"><b>Literal</b><br><code><pre>Literal :<br>&emsp;NullLiteral<br>&emsp;BooleanLiteral<br>&emsp;NumericLiteral<br>&emsp;StringLiteral</pre></code></div><div class="sec-expressions definitions"><b>ArrayLiteral</b><br><code><pre>ArrayLiteral[Yield, Await] :<br>&emsp;`[` <i>Elision?</i> `]`<br>&emsp;`[` ElementList[?Yield, ?Await] `]`<br>&emsp;`[` ElementList[?Yield, ?Await] `,` <i>Elision?</i> `]`</pre></code></div><div class="sec-expressions definitions"><b>ElementList</b><br><code><pre>ElementList[Yield, Await] :<br>&emsp;<i>Elision?</i> AssignmentExpression[+In, ?Yield, ?Await]<br>&emsp;<i>Elision?</i> SpreadElement[?Yield, ?Await]<br>&emsp;ElementList[?Yield, ?Await] `,` <i>Elision?</i> AssignmentExpression[+In, ?Yield, ?Await]<br>&emsp;ElementList[?Yield, ?Await] `,` <i>Elision?</i> SpreadElement[?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>Elision</b><br><code><pre>Elision :<br>&emsp;`,`<br>&emsp;Elision `,`</pre></code></div><div class="sec-expressions definitions"><b>SpreadElement</b><br><code><pre>SpreadElement[Yield, Await] :<br>&emsp;`...` AssignmentExpression[+In, ?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>ObjectLiteral</b><br><code><pre>ObjectLiteral[Yield, Await] :<br>&emsp;`{` `}`<br>&emsp;`{` PropertyDefinitionList[?Yield, ?Await] `}`<br>&emsp;`{` PropertyDefinitionList[?Yield, ?Await] `,` `}`</pre></code><code><pre>ObjectLiteral :<br>&emsp;`{` PropertyDefinitionList `}`<br>&emsp;`{` PropertyDefinitionList `,` `}`</pre></code><code><pre>ObjectLiteral : `{` PropertyDefinitionList `}`</pre></code></div><div class="sec-expressions definitions"><b>PropertyDefinitionList</b><br><code><pre>PropertyDefinitionList[Yield, Await] :<br>&emsp;PropertyDefinition[?Yield, ?Await]<br>&emsp;PropertyDefinitionList[?Yield, ?Await] `,` PropertyDefinition[?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>PropertyDefinition</b><br><code><pre>PropertyDefinition[Yield, Await] :<br>&emsp;IdentifierReference[?Yield, ?Await]<br>&emsp;CoverInitializedName[?Yield, ?Await]<br>&emsp;PropertyName[?Yield, ?Await] `:` AssignmentExpression[+In, ?Yield, ?Await]<br>&emsp;MethodDefinition[?Yield, ?Await]<br>&emsp;`...` AssignmentExpression[+In, ?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>PropertyName</b><br><code><pre>PropertyName[Yield, Await] :<br>&emsp;LiteralPropertyName<br>&emsp;ComputedPropertyName[?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>LiteralPropertyName</b><br><code><pre>LiteralPropertyName :<br>&emsp;IdentifierName<br>&emsp;StringLiteral<br>&emsp;NumericLiteral</pre></code></div><div class="sec-expressions definitions"><b>ComputedPropertyName</b><br><code><pre>ComputedPropertyName[Yield, Await] :<br>&emsp;`[` AssignmentExpression[+In, ?Yield, ?Await] `]`</pre></code></div><div class="sec-expressions definitions"><b>CoverInitializedName</b><br><code><pre>CoverInitializedName[Yield, Await] :<br>&emsp;IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>Initializer</b><br><code><pre>Initializer[In, Yield, Await] :<br>&emsp;`=` AssignmentExpression[?In, ?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>TemplateLiteral</b><br><code><pre>TemplateLiteral[Yield, Await, Tagged] :<br>&emsp;NoSubstitutionTemplate<br>&emsp;SubstitutionTemplate[?Yield, ?Await, ?Tagged]</pre></code><code><pre>TemplateLiteral[Yield, Await, Tagged] : NoSubstitutionTemplate</pre></code></div><div class="sec-expressions definitions"><b>TemplateSpans</b><br><code><pre>TemplateSpans[Yield, Await, Tagged] :<br>&emsp;TemplateTail<br>&emsp;TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail</pre></code><code><pre>TemplateSpans[Yield, Await, Tagged] : TemplateTail</pre></code></div><div class="sec-expressions definitions"><b>TemplateMiddleList</b><br><code><pre>TemplateMiddleList[Yield, Await, Tagged] :<br>&emsp;TemplateMiddle Expression[+In, ?Yield, ?Await]<br>&emsp;TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>MemberExpression</b><br><code><pre>MemberExpression[Yield, Await] :<br>&emsp;PrimaryExpression[?Yield, ?Await]<br>&emsp;MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`<br>&emsp;MemberExpression[?Yield, ?Await] `.` IdentifierName<br>&emsp;MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]<br>&emsp;SuperProperty[?Yield, ?Await]<br>&emsp;MetaProperty<br>&emsp;`new` MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]</pre></code><code><pre>MemberExpression :<br>&emsp;MemberExpression `[` Expression `]`<br>&emsp;MemberExpression `.` IdentifierName<br>&emsp;MemberExpression TemplateLiteral<br>&emsp;SuperProperty<br>&emsp;MetaProperty<br>&emsp;`new` MemberExpression Arguments</pre></code><code><pre>MemberExpression :<br>&emsp;MemberExpression `[` Expression `]`<br>&emsp;MemberExpression `.` IdentifierName<br>&emsp;SuperProperty</pre></code><code><pre>MemberExpression :<br>&emsp;MemberExpression TemplateLiteral<br>&emsp;`new` MemberExpression Arguments</pre></code><code><pre>MemberExpression :<br>&emsp;MemberExpression `[` Expression `]`<br>&emsp;MemberExpression `.` IdentifierName<br>&emsp;SuperProperty<br>&emsp;MetaProperty<br>&emsp;`new` MemberExpression Arguments</pre></code><code><pre>MemberExpression :<br>&emsp;MemberExpression TemplateLiteral</pre></code></div><div class="sec-expressions definitions"><b>SuperProperty</b><br><code><pre>SuperProperty[Yield, Await] :<br>&emsp;`super` `[` Expression[+In, ?Yield, ?Await] `]`<br>&emsp;`super` `.` IdentifierName</pre></code></div><div class="sec-expressions definitions"><b>MetaProperty</b><br><code><pre>MetaProperty :<br>&emsp;NewTarget</pre></code></div><div class="sec-expressions definitions"><b>NewTarget</b><br><code><pre>NewTarget :<br>&emsp;`new` `.` `target`</pre></code></div><div class="sec-expressions definitions"><b>NewExpression</b><br><code><pre>NewExpression[Yield, Await] :<br>&emsp;MemberExpression[?Yield, ?Await]<br>&emsp;`new` NewExpression[?Yield, ?Await]</pre></code><code><pre>NewExpression :<br>&emsp;`new` NewExpression</pre></code><code><pre>NewExpression : `new` NewExpression</pre></code></div><div class="sec-expressions definitions"><b>CallExpression</b><br><code><pre>CallExpression[Yield, Await] :<br>&emsp;CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover<br>&emsp;SuperCall[?Yield, ?Await]<br>&emsp;CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]<br>&emsp;CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`<br>&emsp;CallExpression[?Yield, ?Await] `.` IdentifierName<br>&emsp;CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]</pre></code><code><pre>CallExpression : CoverCallExpressionAndAsyncArrowHead</pre></code><code><pre>CallExpression :<br>&emsp;CallExpression `[` Expression `]`<br>&emsp;CallExpression `.` IdentifierName</pre></code><code><pre>CallExpression :<br>&emsp;CoverCallExpressionAndAsyncArrowHead<br>&emsp;SuperCall<br>&emsp;CallExpression Arguments<br>&emsp;CallExpression TemplateLiteral</pre></code><code><pre>CallExpression :<br>&emsp;SuperCall<br>&emsp;CallExpression `[` Expression `]`<br>&emsp;CallExpression `.` IdentifierName</pre></code><code><pre>CallExpression :<br>&emsp;CoverCallExpressionAndAsyncArrowHead<br>&emsp;CallExpression Arguments<br>&emsp;CallExpression TemplateLiteral</pre></code></div><div class="sec-expressions definitions"><b>CoverCallExpressionAndAsyncArrowHead</b><br><code><pre>CoverCallExpressionAndAsyncArrowHead[Yield, Await] :<br>&emsp;MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]</pre></code><code><pre>CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments</pre></code><p>When processing an instance of the production |CallExpression| the interpretation of |CoverCallExpressionAndAsyncArrowHead| is refined using the following grammar:</p></div><div class="sec-expressions definitions"><b>CallMemberExpression</b><br><code><pre>CallMemberExpression[Yield, Await] :<br>&emsp;MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>SuperCall</b><br><code><pre>SuperCall[Yield, Await] :<br>&emsp;`super` Arguments[?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>Arguments</b><br><code><pre>Arguments[Yield, Await] :<br>&emsp;`(` `)`<br>&emsp;`(` ArgumentList[?Yield, ?Await] `)`<br>&emsp;`(` ArgumentList[?Yield, ?Await] `,` `)`</pre></code></div><div class="sec-expressions definitions"><b>ArgumentList</b><br><code><pre>ArgumentList :<br>&emsp;AssignmentExpression<br>&emsp;ArgumentList `,` AssignmentExpression</pre></code><code><pre>ArgumentList[Yield, Await] :<br>&emsp;AssignmentExpression[+In, ?Yield, ?Await]<br>&emsp;`...` AssignmentExpression[+In, ?Yield, ?Await]<br>&emsp;ArgumentList[?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await]<br>&emsp;ArgumentList[?Yield, ?Await] `,` `...` AssignmentExpression[+In, ?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>LeftHandSideExpression</b><br><code><pre>LeftHandSideExpression[Yield, Await] :<br>&emsp;NewExpression[?Yield, ?Await]<br>&emsp;CallExpression[?Yield, ?Await]</pre></code><code><pre>LeftHandSideExpression :<br>&emsp;CallExpression</pre></code></div><div class="sec-expressions definitions"><b>UpdateExpression</b><br><code><pre>UpdateExpression[Yield, Await] :<br>&emsp;LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`<br>&emsp;LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`</pre></code><code><pre>UpdateExpression[Yield, Await] :<br>&emsp;LeftHandSideExpression[?Yield, ?Await]<br>&emsp;LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`<br>&emsp;LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`<br>&emsp;`++` UnaryExpression[?Yield, ?Await]<br>&emsp;`--` UnaryExpression[?Yield, ?Await]</pre></code><code><pre>UpdateExpression :<br>&emsp;LeftHandSideExpression `++`<br>&emsp;LeftHandSideExpression `--`</pre></code><code><pre>UpdateExpression :<br>&emsp;`++` UnaryExpression<br>&emsp;`--` UnaryExpression</pre></code><code><pre>UpdateExpression :<br>&emsp;LeftHandSideExpression `++`<br>&emsp;LeftHandSideExpression `--`<br>&emsp;`++` UnaryExpression<br>&emsp;`--` UnaryExpression</pre></code></div><div class="sec-expressions definitions"><b>UnaryExpression</b><br><code><pre>UnaryExpression[Yield, Await] :<br>&emsp;UpdateExpression[?Yield, ?Await]<br>&emsp;`delete` UnaryExpression[?Yield, ?Await]<br>&emsp;`void` UnaryExpression[?Yield, ?Await]<br>&emsp;`typeof` UnaryExpression[?Yield, ?Await]<br>&emsp;`+` UnaryExpression[?Yield, ?Await]<br>&emsp;`-` UnaryExpression[?Yield, ?Await]<br>&emsp;`~` UnaryExpression[?Yield, ?Await]<br>&emsp;`!` UnaryExpression[?Yield, ?Await]<br>&emsp;[+Await] AwaitExpression[?Yield]</pre></code><code><pre>UnaryExpression :<br>&emsp;`delete` UnaryExpression<br>&emsp;`void` UnaryExpression<br>&emsp;`typeof` UnaryExpression<br>&emsp;`+` UnaryExpression<br>&emsp;`-` UnaryExpression<br>&emsp;`~` UnaryExpression<br>&emsp;`!` UnaryExpression<br>&emsp;AwaitExpression</pre></code></div><div class="sec-expressions definitions"><b>ExponentiationExpression</b><br><code><pre>ExponentiationExpression[Yield, Await] :<br>&emsp;UnaryExpression[?Yield, ?Await]<br>&emsp;UpdateExpression[?Yield, ?Await] `**` ExponentiationExpression[?Yield, ?Await]</pre></code><code><pre>ExponentiationExpression :<br>&emsp;UpdateExpression `**` ExponentiationExpression</pre></code><code><pre>ExponentiationExpression : UpdateExpression `**` ExponentiationExpression</pre></code></div><div class="sec-expressions definitions"><b>MultiplicativeExpression</b><br><code><pre>MultiplicativeExpression[Yield, Await] :<br>&emsp;ExponentiationExpression[?Yield, ?Await]<br>&emsp;MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]</pre></code><code><pre>MultiplicativeExpression :<br>&emsp;MultiplicativeExpression MultiplicativeOperator ExponentiationExpression</pre></code></div><div class="sec-expressions definitions"><b>MultiplicativeOperator</b><br><code><pre>MultiplicativeOperator : one of<br>&emsp;`*` `/` `%`</pre></code></div><div class="sec-expressions definitions"><b>AdditiveExpression</b><br><code><pre>AdditiveExpression[Yield, Await] :<br>&emsp;MultiplicativeExpression[?Yield, ?Await]<br>&emsp;AdditiveExpression[?Yield, ?Await] `+` MultiplicativeExpression[?Yield, ?Await]<br>&emsp;AdditiveExpression[?Yield, ?Await] `-` MultiplicativeExpression[?Yield, ?Await]</pre></code><code><pre>AdditiveExpression :<br>&emsp;AdditiveExpression `+` MultiplicativeExpression<br>&emsp;AdditiveExpression `-` MultiplicativeExpression</pre></code></div><div class="sec-expressions definitions"><b>ShiftExpression</b><br><code><pre>ShiftExpression[Yield, Await] :<br>&emsp;AdditiveExpression[?Yield, ?Await]<br>&emsp;ShiftExpression[?Yield, ?Await] `&lt;&lt;` AdditiveExpression[?Yield, ?Await]<br>&emsp;ShiftExpression[?Yield, ?Await] `&gt;&gt;` AdditiveExpression[?Yield, ?Await]<br>&emsp;ShiftExpression[?Yield, ?Await] `&gt;&gt;&gt;` AdditiveExpression[?Yield, ?Await]</pre></code><code><pre>ShiftExpression :<br>&emsp;ShiftExpression `&lt;&lt;` AdditiveExpression<br>&emsp;ShiftExpression `&gt;&gt;` AdditiveExpression<br>&emsp;ShiftExpression `&gt;&gt;&gt;` AdditiveExpression</pre></code></div><div class="sec-expressions definitions"><b>RelationalExpression</b><br><code><pre>RelationalExpression[In, Yield, Await] :<br>&emsp;ShiftExpression[?Yield, ?Await]<br>&emsp;RelationalExpression[?In, ?Yield, ?Await] `&lt;` ShiftExpression[?Yield, ?Await]<br>&emsp;RelationalExpression[?In, ?Yield, ?Await] `&gt;` ShiftExpression[?Yield, ?Await]<br>&emsp;RelationalExpression[?In, ?Yield, ?Await] `&lt;=` ShiftExpression[?Yield, ?Await]<br>&emsp;RelationalExpression[?In, ?Yield, ?Await] `&gt;=` ShiftExpression[?Yield, ?Await]<br>&emsp;RelationalExpression[?In, ?Yield, ?Await] `instanceof` ShiftExpression[?Yield, ?Await]<br>&emsp;[+In] RelationalExpression[+In, ?Yield, ?Await] `in` ShiftExpression[?Yield, ?Await]</pre></code><code><pre>RelationalExpression :<br>&emsp;RelationalExpression `&lt;` ShiftExpression<br>&emsp;RelationalExpression `&gt;` ShiftExpression<br>&emsp;RelationalExpression `&lt;=` ShiftExpression<br>&emsp;RelationalExpression `&gt;=` ShiftExpression<br>&emsp;RelationalExpression `instanceof` ShiftExpression<br>&emsp;RelationalExpression `in` ShiftExpression</pre></code></div><div class="sec-expressions definitions"><b>EqualityExpression</b><br><code><pre>EqualityExpression[In, Yield, Await] :<br>&emsp;RelationalExpression[?In, ?Yield, ?Await]<br>&emsp;EqualityExpression[?In, ?Yield, ?Await] `==` RelationalExpression[?In, ?Yield, ?Await]<br>&emsp;EqualityExpression[?In, ?Yield, ?Await] `!=` RelationalExpression[?In, ?Yield, ?Await]<br>&emsp;EqualityExpression[?In, ?Yield, ?Await] `===` RelationalExpression[?In, ?Yield, ?Await]<br>&emsp;EqualityExpression[?In, ?Yield, ?Await] `!==` RelationalExpression[?In, ?Yield, ?Await]</pre></code><code><pre>EqualityExpression :<br>&emsp;EqualityExpression `==` RelationalExpression<br>&emsp;EqualityExpression `!=` RelationalExpression<br>&emsp;EqualityExpression `===` RelationalExpression<br>&emsp;EqualityExpression `!==` RelationalExpression</pre></code></div><div class="sec-expressions definitions"><b>BitwiseANDExpression</b><br><code><pre>BitwiseANDExpression[In, Yield, Await] :<br>&emsp;EqualityExpression[?In, ?Yield, ?Await]<br>&emsp;BitwiseANDExpression[?In, ?Yield, ?Await] `&amp;` EqualityExpression[?In, ?Yield, ?Await]</pre></code><code><pre>BitwiseANDExpression : BitwiseANDExpression `&amp;` EqualityExpression</pre></code></div><div class="sec-expressions definitions"><b>BitwiseXORExpression</b><br><code><pre>BitwiseXORExpression[In, Yield, Await] :<br>&emsp;BitwiseANDExpression[?In, ?Yield, ?Await]<br>&emsp;BitwiseXORExpression[?In, ?Yield, ?Await] `^` BitwiseANDExpression[?In, ?Yield, ?Await]</pre></code><code><pre>BitwiseXORExpression : BitwiseXORExpression `^` BitwiseANDExpression</pre></code></div><div class="sec-expressions definitions"><b>BitwiseORExpression</b><br><code><pre>BitwiseORExpression[In, Yield, Await] :<br>&emsp;BitwiseXORExpression[?In, ?Yield, ?Await]<br>&emsp;BitwiseORExpression[?In, ?Yield, ?Await] `|` BitwiseXORExpression[?In, ?Yield, ?Await]</pre></code><code><pre>BitwiseORExpression : BitwiseORExpression `|` BitwiseXORExpression</pre></code></div><div class="sec-expressions definitions"><b>LogicalANDExpression</b><br><code><pre>LogicalANDExpression[In, Yield, Await] :<br>&emsp;BitwiseORExpression[?In, ?Yield, ?Await]<br>&emsp;LogicalANDExpression[?In, ?Yield, ?Await] `&amp;&amp;` BitwiseORExpression[?In, ?Yield, ?Await]</pre></code><code><pre>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</pre></code></div><div class="sec-expressions definitions"><b>LogicalORExpression</b><br><code><pre>LogicalORExpression[In, Yield, Await] :<br>&emsp;LogicalANDExpression[?In, ?Yield, ?Await]<br>&emsp;LogicalORExpression[?In, ?Yield, ?Await] `||` LogicalANDExpression[?In, ?Yield, ?Await]</pre></code><code><pre>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</pre></code></div><div class="sec-expressions definitions"><b>ConditionalExpression</b><br><code><pre>ConditionalExpression[In, Yield, Await] :<br>&emsp;LogicalORExpression[?In, ?Yield, ?Await]<br>&emsp;LogicalORExpression[?In, ?Yield, ?Await] `?` AssignmentExpression[+In, ?Yield, ?Await] `:` AssignmentExpression[?In, ?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>AssignmentExpression</b><br><code><pre>AssignmentExpression[In, Yield, Await] :<br>&emsp;ConditionalExpression[?In, ?Yield, ?Await]<br>&emsp;[+Yield] YieldExpression[?In, ?Await]<br>&emsp;ArrowFunction[?In, ?Yield, ?Await]<br>&emsp;AsyncArrowFunction[?In, ?Yield, ?Await]<br>&emsp;LeftHandSideExpression[?Yield, ?Await] `=` AssignmentExpression[?In, ?Yield, ?Await] #assignment<br>&emsp;LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]</pre></code><code><pre>AssignmentExpression :<br>&emsp;ArrowFunction<br>&emsp;AsyncArrowFunction</pre></code><code><pre>AssignmentExpression :<br>&emsp;YieldExpression<br>&emsp;LeftHandSideExpression `=` AssignmentExpression<br>&emsp;LeftHandSideExpression AssignmentOperator AssignmentExpression</pre></code><code><pre>AssignmentExpression :<br>&emsp;YieldExpression<br>&emsp;ArrowFunction<br>&emsp;AsyncArrowFunction<br>&emsp;LeftHandSideExpression `=` AssignmentExpression<br>&emsp;LeftHandSideExpression AssignmentOperator AssignmentExpression</pre></code><p>In certain circumstances when processing an instance of the production |AssignmentExpression| the following grammar is used to refine the interpretation of |LeftHandSideExpression|:</p></div><div class="sec-expressions definitions"><b>AssignmentPattern</b><br><code><pre>AssignmentPattern[Yield, Await] :<br>&emsp;ObjectAssignmentPattern[?Yield, ?Await]<br>&emsp;ArrayAssignmentPattern[?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>ObjectAssignmentPattern</b><br><code><pre>ObjectAssignmentPattern[Yield, Await] :<br>&emsp;`{` `}`<br>&emsp;`{` AssignmentRestProperty[?Yield, ?Await] `}`<br>&emsp;`{` AssignmentPropertyList[?Yield, ?Await] `}`<br>&emsp;`{` AssignmentPropertyList[?Yield, ?Await] `,` <i>AssignmentRestProperty[?Yield, ?Await]?</i> `}`</pre></code><code><pre>ObjectAssignmentPattern :<br>&emsp;`{` AssignmentPropertyList `}`<br>&emsp;`{` AssignmentPropertyList `,` `}`</pre></code></div><div class="sec-expressions definitions"><b>ArrayAssignmentPattern</b><br><code><pre>ArrayAssignmentPattern[Yield, Await] :<br>&emsp;`[` <i>Elision?</i> <i>AssignmentRestElement[?Yield, ?Await]?</i> `]`<br>&emsp;`[` AssignmentElementList[?Yield, ?Await] `]`<br>&emsp;`[` AssignmentElementList[?Yield, ?Await] `,` <i>Elision?</i> <i>AssignmentRestElement[?Yield, ?Await]?</i> `]`</pre></code></div><div class="sec-expressions definitions"><b>AssignmentPropertyList</b><br><code><pre>AssignmentPropertyList[Yield, Await] :<br>&emsp;AssignmentProperty[?Yield, ?Await]<br>&emsp;AssignmentPropertyList[?Yield, ?Await] `,` AssignmentProperty[?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>AssignmentElementList</b><br><code><pre>AssignmentElementList[Yield, Await] :<br>&emsp;AssignmentElisionElement[?Yield, ?Await]<br>&emsp;AssignmentElementList[?Yield, ?Await] `,` AssignmentElisionElement[?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>AssignmentElisionElement</b><br><code><pre>AssignmentElisionElement[Yield, Await] :<br>&emsp;<i>Elision?</i> AssignmentElement[?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>AssignmentProperty</b><br><code><pre>AssignmentProperty[Yield, Await] :<br>&emsp;IdentifierReference[?Yield, ?Await] <i>Initializer[+In, ?Yield, ?Await]?</i><br>&emsp;PropertyName[?Yield, ?Await] `:` AssignmentElement[?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>AssignmentElement</b><br><code><pre>AssignmentElement[Yield, Await] :<br>&emsp;DestructuringAssignmentTarget[?Yield, ?Await] <i>Initializer[+In, ?Yield, ?Await]?</i></pre></code></div><div class="sec-expressions definitions"><b>AssignmentRestElement</b><br><code><pre>AssignmentRestElement[Yield, Await] :<br>&emsp;`...` DestructuringAssignmentTarget[?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>DestructuringAssignmentTarget</b><br><code><pre>DestructuringAssignmentTarget[Yield, Await] :<br>&emsp;LeftHandSideExpression[?Yield, ?Await]</pre></code></div><div class="sec-expressions definitions"><b>AssignmentOperator</b><br><code><pre>AssignmentOperator : one of<br>&emsp;`*=` `/=` `%=` `+=` `-=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `^=` `|=` `**=`</pre></code></div><div class="sec-expressions definitions"><b>Expression</b><br><code><pre>Expression[In, Yield, Await] :<br>&emsp;AssignmentExpression[?In, ?Yield, ?Await]<br>&emsp;Expression[?In, ?Yield, ?Await] `,` AssignmentExpression[?In, ?Yield, ?Await]</pre></code><code><pre>Expression :<br>&emsp;AssignmentExpression<br>&emsp;Expression `,` AssignmentExpression</pre></code></div><div class="sec-statements definitions"><b>Statement</b><br><code><pre>Statement[Yield, Await, Return] :<br>&emsp;BlockStatement[?Yield, ?Await, ?Return]<br>&emsp;VariableStatement[?Yield, ?Await]<br>&emsp;EmptyStatement<br>&emsp;ExpressionStatement[?Yield, ?Await]<br>&emsp;IfStatement[?Yield, ?Await, ?Return]<br>&emsp;BreakableStatement[?Yield, ?Await, ?Return]<br>&emsp;ContinueStatement[?Yield, ?Await]<br>&emsp;BreakStatement[?Yield, ?Await]<br>&emsp;[+Return] ReturnStatement[?Yield, ?Await]<br>&emsp;WithStatement[?Yield, ?Await, ?Return]<br>&emsp;LabelledStatement[?Yield, ?Await, ?Return]<br>&emsp;ThrowStatement[?Yield, ?Await]<br>&emsp;TryStatement[?Yield, ?Await, ?Return]<br>&emsp;DebuggerStatement</pre></code><code><pre>Statement :<br>&emsp;VariableStatement<br>&emsp;EmptyStatement<br>&emsp;ExpressionStatement<br>&emsp;ContinueStatement<br>&emsp;BreakStatement<br>&emsp;ReturnStatement<br>&emsp;ThrowStatement<br>&emsp;DebuggerStatement</pre></code><code><pre>Statement :<br>&emsp;VariableStatement<br>&emsp;EmptyStatement<br>&emsp;ExpressionStatement<br>&emsp;ContinueStatement<br>&emsp;ReturnStatement<br>&emsp;ThrowStatement<br>&emsp;DebuggerStatement</pre></code><code><pre>Statement :<br>&emsp;VariableStatement<br>&emsp;EmptyStatement<br>&emsp;ExpressionStatement<br>&emsp;BreakStatement<br>&emsp;ReturnStatement<br>&emsp;ThrowStatement<br>&emsp;DebuggerStatement</pre></code><code><pre>Statement :<br>&emsp;EmptyStatement<br>&emsp;ExpressionStatement<br>&emsp;ContinueStatement<br>&emsp;BreakStatement<br>&emsp;ReturnStatement<br>&emsp;ThrowStatement<br>&emsp;DebuggerStatement</pre></code><code><pre>Statement :<br>&emsp;VariableStatement<br>&emsp;EmptyStatement<br>&emsp;ExpressionStatement<br>&emsp;ContinueStatement<br>&emsp;BreakStatement<br>&emsp;ThrowStatement<br>&emsp;DebuggerStatement</pre></code></div><div class="sec-statements definitions"><b>Declaration</b><br><code><pre>Declaration[Yield, Await] :<br>&emsp;HoistableDeclaration[?Yield, ?Await, ~Default]<br>&emsp;ClassDeclaration[?Yield, ?Await, ~Default]<br>&emsp;LexicalDeclaration[+In, ?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>HoistableDeclaration</b><br><code><pre>HoistableDeclaration[Yield, Await, Default] :<br>&emsp;FunctionDeclaration[?Yield, ?Await, ?Default]<br>&emsp;GeneratorDeclaration[?Yield, ?Await, ?Default]<br>&emsp;AsyncFunctionDeclaration[?Yield, ?Await, ?Default]<br>&emsp;AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]</pre></code><code><pre>HoistableDeclaration :<br>&emsp;GeneratorDeclaration<br>&emsp;AsyncFunctionDeclaration<br>&emsp;AsyncGeneratorDeclaration</pre></code><code><pre>HoistableDeclaration : FunctionDeclaration</pre></code></div><div class="sec-statements definitions"><b>BreakableStatement</b><br><code><pre>BreakableStatement[Yield, Await, Return] :<br>&emsp;IterationStatement[?Yield, ?Await, ?Return]<br>&emsp;SwitchStatement[?Yield, ?Await, ?Return]</pre></code><code><pre>BreakableStatement :<br>&emsp;IterationStatement<br>&emsp;SwitchStatement</pre></code></div><div class="sec-statements definitions"><b>BlockStatement</b><br><code><pre>BlockStatement[Yield, Await, Return] :<br>&emsp;Block[?Yield, ?Await, ?Return]</pre></code></div><div class="sec-statements definitions"><b>Block</b><br><code><pre>Block :<br>&emsp;`{` StatementList `}`</pre></code><code><pre>Block[Yield, Await, Return] :<br>&emsp;`{` <i>StatementList[?Yield, ?Await, ?Return]?</i> `}`</pre></code><code><pre>Block : `{` `}`</pre></code></div><div class="sec-statements definitions"><b>StatementList</b><br><code><pre>StatementList[Return] :<br>&emsp;ReturnStatement<br>&emsp;ExpressionStatement</pre></code><code><pre>StatementList :<br>&emsp;ReturnStatement<br>&emsp;ExpressionStatement</pre></code><code><pre>StatementList[Return, In] :<br>&emsp;ReturnStatement<br>&emsp;ExpressionStatement</pre></code><code><pre>StatementList :<br>&emsp;ReturnStatement<br>&emsp;ExpressionStatement[+In]</pre></code><code><pre>StatementList :<br>&emsp;ReturnStatement<br>&emsp;ExpressionStatement_In</pre></code><code><pre>StatementList :<br>&emsp;ReturnStatement<br>&emsp;ExpressionStatement[~In]</pre></code><code><pre>StatementList[Return] :<br>&emsp;[+Return] ReturnStatement<br>&emsp;ExpressionStatement</pre></code><code><pre>StatementList :<br>&emsp;ExpressionStatement</pre></code><code><pre>StatementList[Return] :<br>&emsp;[~Return] ReturnStatement<br>&emsp;ExpressionStatement</pre></code><code><pre>StatementList[Yield, Await, Return] :<br>&emsp;StatementListItem[?Yield, ?Await, ?Return]<br>&emsp;StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return]</pre></code></div><div class="sec-statements definitions"><b>StatementListItem</b><br><code><pre>StatementListItem[Yield, Await, Return] :<br>&emsp;Statement[?Yield, ?Await, ?Return]<br>&emsp;Declaration[?Yield, ?Await]</pre></code><code><pre>StatementListItem : Declaration</pre></code></div><div class="sec-statements definitions"><b>LexicalDeclaration</b><br><code><pre>LexicalDeclaration[In, Yield, Await] :<br>&emsp;LetOrConst BindingList[?In, ?Yield, ?Await] `;`</pre></code></div><div class="sec-statements definitions"><b>LetOrConst</b><br><code><pre>LetOrConst : one of<br>&emsp;`let` `const`</pre></code></div><div class="sec-statements definitions"><b>BindingList</b><br><code><pre>BindingList[In, Yield, Await] :<br>&emsp;LexicalBinding[?In, ?Yield, ?Await]<br>&emsp;BindingList[?In, ?Yield, ?Await] `,` LexicalBinding[?In, ?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>LexicalBinding</b><br><code><pre>LexicalBinding[In, Yield, Await] :<br>&emsp;BindingIdentifier[?Yield, ?Await] <i>Initializer[?In, ?Yield, ?Await]?</i><br>&emsp;BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>VariableStatement</b><br><code><pre>VariableStatement[Yield, Await] :<br>&emsp;`var` VariableDeclarationList[+In, ?Yield, ?Await] `;`</pre></code></div><div class="sec-statements definitions"><b>VariableDeclarationList</b><br><code><pre>VariableDeclarationList[In, Yield, Await] :<br>&emsp;VariableDeclaration[?In, ?Yield, ?Await]<br>&emsp;VariableDeclarationList[?In, ?Yield, ?Await] `,` VariableDeclaration[?In, ?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>VariableDeclaration</b><br><code><pre>VariableDeclaration :<br>&emsp;BindingIdentifier <i>Initializer?</i></pre></code><code><pre>VariableDeclaration :<br>&emsp;BindingIdentifier<br>&emsp;BindingIdentifier Initializer</pre></code><code><pre>VariableDeclaration :<br>&emsp;BindingIdentifier <i>Initializer[+In]?</i></pre></code><code><pre>VariableDeclaration :<br>&emsp;BindingIdentifier<br>&emsp;BindingIdentifier Initializer_In</pre></code><code><pre>VariableDeclaration[In] :<br>&emsp;BindingIdentifier Initializer[?In]</pre></code><code><pre>VariableDeclaration :<br>&emsp;BindingIdentifier Initializer</pre></code><code><pre>VariableDeclaration[In, Yield, Await] :<br>&emsp;BindingIdentifier[?Yield, ?Await] <i>Initializer[?In, ?Yield, ?Await]?</i><br>&emsp;BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>BindingPattern</b><br><code><pre>BindingPattern[Yield, Await] :<br>&emsp;ObjectBindingPattern[?Yield, ?Await]<br>&emsp;ArrayBindingPattern[?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>ObjectBindingPattern</b><br><code><pre>ObjectBindingPattern[Yield, Await] :<br>&emsp;`{` `}`<br>&emsp;`{` BindingRestProperty[?Yield, ?Await] `}`<br>&emsp;`{` BindingPropertyList[?Yield, ?Await] `}`<br>&emsp;`{` BindingPropertyList[?Yield, ?Await] `,` <i>BindingRestProperty[?Yield, ?Await]?</i> `}`</pre></code><code><pre>ObjectBindingPattern :<br>&emsp;`{` BindingPropertyList `}`<br>&emsp;`{` BindingPropertyList `,` `}`</pre></code></div><div class="sec-statements definitions"><b>ArrayBindingPattern</b><br><code><pre>ArrayBindingPattern[Yield, Await] :<br>&emsp;`[` <i>Elision?</i> <i>BindingRestElement[?Yield, ?Await]?</i> `]`<br>&emsp;`[` BindingElementList[?Yield, ?Await] `]`<br>&emsp;`[` BindingElementList[?Yield, ?Await] `,` <i>Elision?</i> <i>BindingRestElement[?Yield, ?Await]?</i> `]`</pre></code></div><div class="sec-statements definitions"><b>BindingPropertyList</b><br><code><pre>BindingPropertyList[Yield, Await] :<br>&emsp;BindingProperty[?Yield, ?Await]<br>&emsp;BindingPropertyList[?Yield, ?Await] `,` BindingProperty[?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>BindingElementList</b><br><code><pre>BindingElementList[Yield, Await] :<br>&emsp;BindingElisionElement[?Yield, ?Await]<br>&emsp;BindingElementList[?Yield, ?Await] `,` BindingElisionElement[?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>BindingElisionElement</b><br><code><pre>BindingElisionElement[Yield, Await] :<br>&emsp;<i>Elision?</i> BindingElement[?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>BindingProperty</b><br><code><pre>BindingProperty[Yield, Await] :<br>&emsp;SingleNameBinding[?Yield, ?Await]<br>&emsp;PropertyName[?Yield, ?Await] `:` BindingElement[?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>BindingElement</b><br><code><pre>BindingElement[Yield, Await] :<br>&emsp;SingleNameBinding[?Yield, ?Await]<br>&emsp;BindingPattern[?Yield, ?Await] <i>Initializer[+In, ?Yield, ?Await]?</i></pre></code></div><div class="sec-statements definitions"><b>SingleNameBinding</b><br><code><pre>SingleNameBinding[Yield, Await] :<br>&emsp;BindingIdentifier[?Yield, ?Await] <i>Initializer[+In, ?Yield, ?Await]?</i></pre></code></div><div class="sec-statements definitions"><b>BindingRestElement</b><br><code><pre>BindingRestElement[Yield, Await] :<br>&emsp;`...` BindingIdentifier[?Yield, ?Await]<br>&emsp;`...` BindingPattern[?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>EmptyStatement</b><br><code><pre>EmptyStatement :<br>&emsp;`;`</pre></code></div><div class="sec-statements definitions"><b>ExpressionStatement</b><br><code><pre>ExpressionStatement[Yield, Await] :<br>&emsp;[lookahead &lt;! {`{`, `function`, `async` [no |LineTerminator| here] `function`, `class`, `let [`}] Expression[+In, ?Yield, ?Await] `;`</pre></code></div><div class="sec-statements definitions"><b>IfStatement</b><br><code><pre>IfStatement[Yield, Await, Return] :<br>&emsp;`if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` Statement[?Yield, ?Await, ?Return]<br>&emsp;`if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]</pre></code><code><pre>IfStatement :<br>&emsp;`if` `(` Expression `)` Statement `else` Statement<br>&emsp;`if` `(` Expression `)` Statement</pre></code><code><pre>IfStatement : `if` `(` Expression `)` Statement</pre></code><code><pre>IfStatement[Yield, Await, Return] :<br>&emsp;`if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` Statement[?Yield, ?Await, ?Return]<br>&emsp;`if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` FunctionDeclaration[?Yield, ?Await, ~Default]<br>&emsp;`if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` FunctionDeclaration[?Yield, ?Await, ~Default]<br>&emsp;`if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default]</pre></code></div><div class="sec-statements definitions"><b>IterationStatement</b><br><code><pre>IterationStatement :<br>&emsp;`for` `(` LexicalDeclaration <i>Expression?</i> `;` <i>Expression?</i> `)` Statement</pre></code><code><pre>IterationStatement :<br>&emsp;`for` `(` LexicalDeclaration `;` <i>Expression?</i> `)` Statement<br>&emsp;`for` `(` LexicalDeclaration Expression `;` <i>Expression?</i> `)` Statement</pre></code><code><pre>IterationStatement :<br>&emsp;`for` `(` LexicalDeclaration `;` `)` Statement<br>&emsp;`for` `(` LexicalDeclaration `;` Expression `)` Statement<br>&emsp;`for` `(` LexicalDeclaration Expression `;` `)` Statement<br>&emsp;`for` `(` LexicalDeclaration Expression `;` Expression `)` Statement</pre></code><code><pre>IterationStatement[Yield, Await, Return] :<br>&emsp;`do` Statement[?Yield, ?Await, ?Return] `while` `(` Expression[+In, ?Yield, ?Await] `)` `;`<br>&emsp;`while` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]<br>&emsp;`for` `(` [lookahead &lt;! {`let [`}] <i>Expression[~In, ?Yield, ?Await]?</i> `;` <i>Expression[+In, ?Yield, ?Await]?</i> `;` <i>Expression[+In, ?Yield, ?Await]?</i> `)` Statement[?Yield, ?Await, ?Return]<br>&emsp;`for` `(` `var` VariableDeclarationList[~In, ?Yield, ?Await] `;` <i>Expression[+In, ?Yield, ?Await]?</i> `;` <i>Expression[+In, ?Yield, ?Await]?</i> `)` Statement[?Yield, ?Await, ?Return]<br>&emsp;`for` `(` LexicalDeclaration[~In, ?Yield, ?Await] <i>Expression[+In, ?Yield, ?Await]?</i> `;` <i>Expression[+In, ?Yield, ?Await]?</i> `)` Statement[?Yield, ?Await, ?Return]<br>&emsp;`for` `(` [lookahead &lt;! {`let [`}] LeftHandSideExpression[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]<br>&emsp;`for` `(` `var` ForBinding[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]<br>&emsp;`for` `(` ForDeclaration[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]<br>&emsp;`for` `(` [lookahead != `let` ] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]<br>&emsp;`for` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]<br>&emsp;`for` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]<br>&emsp;[+Await] `for` `await` `(` [lookahead != `let` ] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]<br>&emsp;[+Await] `for` `await` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]<br>&emsp;[+Await] `for` `await` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]</pre></code><code><pre>IterationStatement :<br>&emsp;`do` Statement `while` `(` Expression `)` `;`<br>&emsp;`while` `(` Expression `)` Statement<br>&emsp;`for` `(` <i>Expression?</i> `;` <i>Expression?</i> `;` <i>Expression?</i> `)` Statement<br>&emsp;`for` `(` `var` VariableDeclarationList `;` <i>Expression?</i> `;` <i>Expression?</i> `)` Statement<br>&emsp;`for` `(` LexicalDeclaration <i>Expression?</i> `;` <i>Expression?</i> `)` Statement<br>&emsp;`for` `(` LeftHandSideExpression `in` Expression `)` Statement<br>&emsp;`for` `(` `var` ForBinding `in` Expression `)` Statement<br>&emsp;`for` `(` ForDeclaration `in` Expression `)` Statement<br>&emsp;`for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement<br>&emsp;`for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement<br>&emsp;`for` `(` ForDeclaration `of` AssignmentExpression `)` Statement<br>&emsp;`for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement<br>&emsp;`for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement<br>&emsp;`for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement</pre></code><code><pre>IterationStatement :<br>&emsp;`for` `(` <i>Expression?</i> `;` <i>Expression?</i> `;` <i>Expression?</i> `)` Statement<br>&emsp;`for` `(` `var` VariableDeclarationList `;` <i>Expression?</i> `;` <i>Expression?</i> `)` Statement<br>&emsp;`for` `(` LexicalDeclaration <i>Expression?</i> `;` <i>Expression?</i> `)` Statement</pre></code><code><pre>IterationStatement :<br>&emsp;`for` `(` LeftHandSideExpression `in` Expression `)` Statement<br>&emsp;`for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement<br>&emsp;`for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement</pre></code><code><pre>IterationStatement :<br>&emsp;`for` `(` ForDeclaration `in` Expression `)` Statement<br>&emsp;`for` `(` ForDeclaration `of` AssignmentExpression `)` Statement<br>&emsp;`for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement</pre></code><code><pre>IterationStatement :<br>&emsp;`for` `(` LeftHandSideExpression `in` Expression `)` Statement<br>&emsp;`for` `(` `var` ForBinding `in` Expression `)` Statement<br>&emsp;`for` `(` ForDeclaration `in` Expression `)` Statement<br>&emsp;`for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement<br>&emsp;`for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement<br>&emsp;`for` `(` ForDeclaration `of` AssignmentExpression `)` Statement<br>&emsp;`for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement<br>&emsp;`for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement<br>&emsp;`for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement</pre></code><code><pre>IterationStatement :<br>&emsp;`for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement<br>&emsp;`for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement</pre></code><code><pre>IterationStatement :<br>&emsp;`for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement<br>&emsp;`for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement</pre></code><code><pre>IterationStatement :<br>&emsp;`for` `(` ForDeclaration `of` AssignmentExpression `)` Statement<br>&emsp;`for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement</pre></code><code><pre>IterationStatement :<br>&emsp;`for` `(` ForDeclaration `in` Expression `)` Statement<br>&emsp;`for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement</pre></code><code><pre>IterationStatement :<br>&emsp;`for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement<br>&emsp;`for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement</pre></code><code><pre>IterationStatement : `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement</pre></code><code><pre>IterationStatement : `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement</pre></code><code><pre>IterationStatement : `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement</pre></code><code><pre>IterationStatement :<br>&emsp;`for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement<br>&emsp;`for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement<br>&emsp;`for` `(` ForDeclaration `of` AssignmentExpression `)` Statement</pre></code><code><pre>IterationStatement :<br>&emsp;`do` Statement `while` `(` Expression `)` `;`<br>&emsp;`while` `(` Expression `)` Statement<br>&emsp;`for` `(` <i>Expression?</i> `;` <i>Expression?</i> `;` <i>Expression?</i> `)` Statement<br>&emsp;`for` `(` `var` VariableDeclarationList `;` <i>Expression?</i> `;` <i>Expression?</i> `)` Statement<br>&emsp;`for` `(` LexicalDeclaration <i>Expression?</i> `;` <i>Expression?</i> `)` Statement<br>&emsp;`for` `(` LeftHandSideExpression `in` Expression `)` Statement<br>&emsp;`for` `(` `var` ForBinding `in` Expression `)` Statement<br>&emsp;`for` `(` ForDeclaration `in` Expression `)` Statement</pre></code><code><pre>IterationStatement[Yield, Await, Return] :<br>&emsp;`for` `(` `var` BindingIdentifier[?Yield, ?Await] Initializer[~In, ?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]</pre></code></div><div class="sec-statements definitions"><b>ForDeclaration</b><br><code><pre>ForDeclaration[Yield, Await] :<br>&emsp;LetOrConst ForBinding[?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>ForBinding</b><br><code><pre>ForBinding[Yield, Await] :<br>&emsp;BindingIdentifier[?Yield, ?Await]<br>&emsp;BindingPattern[?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>ContinueStatement</b><br><code><pre>ContinueStatement[Yield, Await] :<br>&emsp;`continue` `;`<br>&emsp;`continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`</pre></code><code><pre>ContinueStatement : `continue` `;`</pre></code></div><div class="sec-statements definitions"><b>BreakStatement</b><br><code><pre>BreakStatement[Yield, Await] :<br>&emsp;`break` `;`<br>&emsp;`break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`</pre></code></div><div class="sec-statements definitions"><b>ReturnStatement</b><br><code><pre>ReturnStatement[Yield, Await] :<br>&emsp;`return` `;`<br>&emsp;`return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`</pre></code><code><pre>ReturnStatement : `return` `;`</pre></code></div><div class="sec-statements definitions"><b>WithStatement</b><br><code><pre>WithStatement[Yield, Await, Return] :<br>&emsp;`with` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]</pre></code><code><pre>WithStatement : `with` `(` Expression `)` Statement</pre></code></div><div class="sec-statements definitions"><b>SwitchStatement</b><br><code><pre>SwitchStatement[Yield, Await, Return] :<br>&emsp;`switch` `(` Expression[+In, ?Yield, ?Await] `)` CaseBlock[?Yield, ?Await, ?Return]</pre></code></div><div class="sec-statements definitions"><b>CaseBlock</b><br><code><pre>CaseBlock[Yield, Await, Return] :<br>&emsp;`{` <i>CaseClauses[?Yield, ?Await, ?Return]?</i> `}`<br>&emsp;`{` <i>CaseClauses[?Yield, ?Await, ?Return]?</i> DefaultClause[?Yield, ?Await, ?Return] <i>CaseClauses[?Yield, ?Await, ?Return]?</i> `}`</pre></code><code><pre>CaseBlock : `{` `}`</pre></code></div><div class="sec-statements definitions"><b>CaseClauses</b><br><code><pre>CaseClauses[Yield, Await, Return] :<br>&emsp;CaseClause[?Yield, ?Await, ?Return]<br>&emsp;CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield, ?Await, ?Return]</pre></code></div><div class="sec-statements definitions"><b>CaseClause</b><br><code><pre>CaseClause[Yield, Await, Return] :<br>&emsp;`case` Expression[+In, ?Yield, ?Await] `:` <i>StatementList[?Yield, ?Await, ?Return]?</i></pre></code><code><pre>CaseClause : `case` Expression `:` <i>StatementList?</i></pre></code></div><div class="sec-statements definitions"><b>DefaultClause</b><br><code><pre>DefaultClause[Yield, Await, Return] :<br>&emsp;`default` `:` <i>StatementList[?Yield, ?Await, ?Return]?</i></pre></code><code><pre>DefaultClause : `default` `:` <i>StatementList?</i></pre></code></div><div class="sec-statements definitions"><b>LabelledStatement</b><br><code><pre>LabelledStatement[Yield, Await, Return] :<br>&emsp;LabelIdentifier[?Yield, ?Await] `:` LabelledItem[?Yield, ?Await, ?Return]</pre></code><code><pre>LabelledStatement :<br>&emsp;LabelIdentifier `:` LabelledItem</pre></code></div><div class="sec-statements definitions"><b>LabelledItem</b><br><code><pre>LabelledItem[Yield, Await, Return] :<br>&emsp;Statement[?Yield, ?Await, ?Return]<br>&emsp;FunctionDeclaration[?Yield, ?Await, ~Default]</pre></code><code><pre>LabelledItem : FunctionDeclaration</pre></code></div><div class="sec-statements definitions"><b>ThrowStatement</b><br><code><pre>ThrowStatement :<br>&emsp;`throw` [no LineTerminator here] Expression `;`</pre></code><code><pre>ThrowStatement[Yield, Await] :<br>&emsp;`throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`</pre></code></div><div class="sec-statements definitions"><b>TryStatement</b><br><code><pre>TryStatement[Yield, Await, Return] :<br>&emsp;`try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]<br>&emsp;`try` Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]<br>&emsp;`try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]</pre></code><code><pre>TryStatement : `try` Block Finally</pre></code></div><div class="sec-statements definitions"><b>Catch</b><br><code><pre>Catch[Yield, Await, Return] :<br>&emsp;`catch` `(` CatchParameter[?Yield, ?Await] `)` Block[?Yield, ?Await, ?Return]</pre></code></div><div class="sec-statements definitions"><b>Finally</b><br><code><pre>Finally[Yield, Await, Return] :<br>&emsp;`finally` Block[?Yield, ?Await, ?Return]</pre></code></div><div class="sec-statements definitions"><b>CatchParameter</b><br><code><pre>CatchParameter[Yield, Await] :<br>&emsp;BindingIdentifier[?Yield, ?Await]<br>&emsp;BindingPattern[?Yield, ?Await]</pre></code></div><div class="sec-statements definitions"><b>DebuggerStatement</b><br><code><pre>DebuggerStatement :<br>&emsp;`debugger` `;`</pre></code></div><div class="sec-functions-and-classes definitions"><b>FunctionDeclaration</b><br><code><pre>FunctionDeclaration[Yield, Await, Default] :<br>&emsp;`function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`<br>&emsp;[+Default] `function` `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`</pre></code><code><pre>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</pre></code></div><div class="sec-functions-and-classes definitions"><b>FunctionExpression</b><br><code><pre>FunctionExpression :<br>&emsp;`function` <i>BindingIdentifier[~Yield, ~Await]?</i> `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`</pre></code><code><pre>FunctionExpression : `function` <i>BindingIdentifier?</i> `(` FormalParameters `)` `{` FunctionBody `}`</pre></code></div><div class="sec-functions-and-classes definitions"><b>UniqueFormalParameters</b><br><code><pre>UniqueFormalParameters[Yield, Await] :<br>&emsp;FormalParameters[?Yield, ?Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>FormalParameters</b><br><code><pre>FormalParameters[Yield, Await] :<br>&emsp;FormalParameters[?Yield, ?Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>FormalParameterList</b><br><code><pre>FormalParameterList[Yield, Await] :<br>&emsp;FormalParameter[?Yield, ?Await]<br>&emsp;FormalParameterList[?Yield, ?Await] `,` FormalParameter[?Yield, ?Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>FunctionRestParameter</b><br><code><pre>FunctionRestParameter[Yield, Await] :<br>&emsp;BindingRestElement[?Yield, ?Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>FormalParameter</b><br><code><pre>FormalParameter[Yield, Await] :<br>&emsp;BindingElement[?Yield, ?Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>FunctionBody</b><br><code><pre>FunctionBody[Yield, Await] :<br>&emsp;FunctionStatementList[?Yield, ?Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>FunctionStatementList</b><br><code><pre>FunctionStatementList[Yield, Await] :<br>&emsp;<i>StatementList[?Yield, ?Await, +Return]?</i></pre></code><code><pre>FunctionStatementList : [empty]</pre></code></div><div class="sec-functions-and-classes definitions"><b>ArrowFunction</b><br><code><pre>ArrowFunction[In, Yield, Await] :<br>&emsp;ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=&gt;` ConciseBody[?In]</pre></code></div><div class="sec-functions-and-classes definitions"><b>ArrowParameters</b><br><code><pre>ArrowParameters[Yield, Await] :<br>&emsp;BindingIdentifier[?Yield, ?Await]<br>&emsp;CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover</pre></code></div><div class="sec-functions-and-classes definitions"><b>ConciseBody</b><br><code><pre>ConciseBody[In] :<br>&emsp;[lookahead != `{` ] AssignmentExpression[?In, ~Yield, ~Await]<br>&emsp;`{` FunctionBody[~Yield, ~Await] `}`</pre></code><p>When the production |ArrowParameters| is recognized the following grammar is used to refine the interpretation of |CoverParenthesizedExpressionAndArrowParameterList|:</p></div><div class="sec-functions-and-classes definitions"><b>ArrowFormalParameters</b><br><code><pre>ArrowFormalParameters[Yield, Await] :<br>&emsp;`(` UniqueFormalParameters[?Yield, ?Await] `)`</pre></code></div><div class="sec-functions-and-classes definitions"><b>AsyncArrowFunction</b><br><code><pre>AsyncArrowFunction[In, Yield, Await] :<br>&emsp;`async` [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] `=>` AsyncConciseBody[?In]<br>&emsp;CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] `=>` AsyncConciseBody[?In] #callcover</pre></code><code><pre>AsyncArrowFunction : `async` [no LineTerminator here] AsyncArrowBindingIdentifier [no LineTerminator here] `=>` AsyncConciseBody</pre></code><code><pre>AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead [no LineTerminator here] `=>` AsyncConciseBody</pre></code></div><div class="sec-functions-and-classes definitions"><b>AsyncConciseBody</b><br><code><pre>AsyncConciseBody[In] :<br>&emsp;[lookahead != `{`] AssignmentExpression[?In, ~Yield, +Await]<br>&emsp;`{` AsyncFunctionBody `}`</pre></code><code><pre>AsyncConciseBody : [lookahead != `{`] AssignmentExpression</pre></code><code><pre>AsyncConciseBody : `{` AsyncFunctionBody `}`</pre></code><p>When the production |AsyncArrowFunction| is recognized the following grammar is used to refine the interpretation of |CoverParenthesizedExpressionAndArrowParameterList|:</p></div><div class="sec-functions-and-classes definitions"><b>AsyncArrowHead</b><br><code><pre>AsyncArrowHead :<br>&emsp;`async` [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>MethodDefinition</b><br><code><pre>MethodDefinition[Yield, Await] :<br>&emsp;PropertyName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`<br>&emsp;GeneratorMethod[?Yield, ?Await]<br>&emsp;AsyncMethod[?Yield, ?Await]<br>&emsp;AsyncGeneratorMethod[?Yield, ?Await]<br>&emsp;`get` PropertyName[?Yield, ?Await] `(` `)` `{` FunctionBody[~Yield, ~Await] `}`<br>&emsp;`set` PropertyName[?Yield, ?Await] `(` PropertySetParameterList `)` `{` FunctionBody[~Yield, ~Await] `}`</pre></code><code><pre>MethodDefinition :<br>&emsp;PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`<br>&emsp;`get` PropertyName `(` `)` `{` FunctionBody `}`<br>&emsp;`set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`</pre></code><code><pre>MethodDefinition :<br>&emsp;GeneratorMethod<br>&emsp;AsyncMethod<br>&emsp;AsyncGeneratorMethod<br>&emsp;`get` PropertyName `(` `)` `{` FunctionBody `}`<br>&emsp;`set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`</pre></code></div><div class="sec-functions-and-classes definitions"><b>PropertySetParameterList</b><br><code><pre>PropertySetParameterList :<br>&emsp;FormalParameter[~Yield, ~Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>GeneratorMethod</b><br><code><pre>GeneratorMethod[Yield, Await] :<br>&emsp;`*` PropertyName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`</pre></code></div><div class="sec-functions-and-classes definitions"><b>GeneratorDeclaration</b><br><code><pre>GeneratorDeclaration[Yield, Await, Default] :<br>&emsp;`function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`<br>&emsp;[+Default] `function` `*` `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`</pre></code><code><pre>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</pre></code></div><div class="sec-functions-and-classes definitions"><b>GeneratorExpression</b><br><code><pre>GeneratorExpression :<br>&emsp;`function` `*` <i>BindingIdentifier[+Yield, ~Await]?</i> `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`</pre></code><code><pre>GeneratorExpression : `function` `*` <i>BindingIdentifier?</i> `(` FormalParameters `)` `{` GeneratorBody `}`</pre></code></div><div class="sec-functions-and-classes definitions"><b>GeneratorBody</b><br><code><pre>GeneratorBody :<br>&emsp;FunctionBody[+Yield, ~Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>YieldExpression</b><br><code><pre>YieldExpression[In, Await] :<br>&emsp;`yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]<br>&emsp;`yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]</pre></code><code><pre>YieldExpression[In, Await] :<br>&emsp;`yield`<br>&emsp;`yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]<br>&emsp;`yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>AsyncMethod</b><br><code><pre>AsyncMethod[Yield, Await] :<br>&emsp;`async` [no LineTerminator here] PropertyName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`</pre></code><code><pre>AsyncMethod : `async` [no LineTerminator here] PropertyName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`</pre></code></div><div class="sec-functions-and-classes definitions"><b>AsyncFunctionDeclaration</b><br><code><pre>AsyncFunctionDeclaration[Yield, Await, Default] :<br>&emsp;`async` [no LineTerminator here] `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`<br>&emsp;[+Default] `async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`</pre></code><code><pre>AsyncFunctionDeclaration : `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`</pre></code><code><pre>AsyncFunctionDeclaration : `async` [no LineTerminator here] `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`</pre></code></div><div class="sec-functions-and-classes definitions"><b>AsyncFunctionExpression</b><br><code><pre>AsyncFunctionExpression :<br>&emsp;`async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`<br>&emsp;`async` [no LineTerminator here] `function` BindingIdentifier[~Yield, +Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`</pre></code><code><pre>AsyncFunctionExpression : `async` [no LineTerminator here] `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`</pre></code><code><pre>AsyncFunctionExpression : `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`</pre></code></div><div class="sec-functions-and-classes definitions"><b>AsyncFunctionBody</b><br><code><pre>AsyncFunctionBody :<br>&emsp;FunctionBody[~Yield, +Await]</pre></code><code><pre>AsyncFunctionBody : FunctionBody</pre></code></div><div class="sec-functions-and-classes definitions"><b>AwaitExpression</b><br><code><pre>AwaitExpression[Yield] :<br>&emsp;`await` UnaryExpression[?Yield, +Await]</pre></code><code><pre>AwaitExpression : `await` UnaryExpression</pre></code></div><div class="sec-functions-and-classes definitions"><b>ClassDeclaration</b><br><code><pre>ClassDeclaration[Yield, Await, Default] :<br>&emsp;`class` BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]<br>&emsp;[+Default] `class` ClassTail[?Yield, ?Await]</pre></code><code><pre>ClassDeclaration : `class` BindingIdentifier ClassTail</pre></code></div><div class="sec-functions-and-classes definitions"><b>ClassExpression</b><br><code><pre>ClassExpression[Yield, Await] :<br>&emsp;`class` <i>BindingIdentifier[?Yield, ?Await]?</i> ClassTail[?Yield, ?Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>ClassTail</b><br><code><pre>ClassTail[Yield, Await] :<br>&emsp;<i>ClassHeritage[?Yield, ?Await]?</i> `{` <i>ClassBody[?Yield, ?Await]?</i> `}`</pre></code></div><div class="sec-functions-and-classes definitions"><b>ClassHeritage</b><br><code><pre>ClassHeritage[Yield, Await] :<br>&emsp;`extends` LeftHandSideExpression[?Yield, ?Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>ClassBody</b><br><code><pre>ClassBody[Yield, Await] :<br>&emsp;ClassElementList[?Yield, ?Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>ClassElementList</b><br><code><pre>ClassElementList[Yield, Await] :<br>&emsp;ClassElement[?Yield, ?Await]<br>&emsp;ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await]</pre></code></div><div class="sec-functions-and-classes definitions"><b>ClassElement</b><br><code><pre>ClassElement[Yield, Await] :<br>&emsp;MethodDefinition[?Yield, ?Await]<br>&emsp;`static` MethodDefinition[?Yield, ?Await]<br>&emsp;`;`</pre></code></div><div class="sec-scripts-and-modules definitions"><b>Script</b><br><code><pre>Script :<br>&emsp;<i>ScriptBody?</i></pre></code></div><div class="sec-scripts-and-modules definitions"><b>ScriptBody</b><br><code><pre>ScriptBody :<br>&emsp;StatementList[~Yield, ~Await, ~Return]</pre></code></div><div class="sec-scripts-and-modules definitions"><b>Module</b><br><code><pre>Module :<br>&emsp;<i>ModuleBody?</i></pre></code></div><div class="sec-scripts-and-modules definitions"><b>ModuleBody</b><br><code><pre>ModuleBody :<br>&emsp;ModuleItemList</pre></code></div><div class="sec-scripts-and-modules definitions"><b>ModuleItemList</b><br><code><pre>ModuleItemList :<br>&emsp;ModuleItem<br>&emsp;ModuleItemList ModuleItem</pre></code></div><div class="sec-scripts-and-modules definitions"><b>ModuleItem</b><br><code><pre>ModuleItem :<br>&emsp;ImportDeclaration<br>&emsp;ExportDeclaration<br>&emsp;StatementListItem[~Yield, ~Await, ~Return]</pre></code><code><pre>ModuleItem :<br>&emsp;ImportDeclaration<br>&emsp;ExportDeclaration</pre></code><code><pre>ModuleItem :<br>&emsp;ImportDeclaration<br>&emsp;StatementListItem</pre></code><code><pre>ModuleItem :<br>&emsp;ExportDeclaration<br>&emsp;StatementListItem</pre></code></div><div class="sec-scripts-and-modules definitions"><b>ImportDeclaration</b><br><code><pre>ImportDeclaration :<br>&emsp;`import` ImportClause FromClause `;`<br>&emsp;`import` ModuleSpecifier `;`</pre></code></div><div class="sec-scripts-and-modules definitions"><b>ImportClause</b><br><code><pre>ImportClause :<br>&emsp;ImportedDefaultBinding<br>&emsp;NameSpaceImport<br>&emsp;NamedImports<br>&emsp;ImportedDefaultBinding `,` NameSpaceImport<br>&emsp;ImportedDefaultBinding `,` NamedImports</pre></code></div><div class="sec-scripts-and-modules definitions"><b>ImportedDefaultBinding</b><br><code><pre>ImportedDefaultBinding :<br>&emsp;ImportedBinding</pre></code></div><div class="sec-scripts-and-modules definitions"><b>NameSpaceImport</b><br><code><pre>NameSpaceImport :<br>&emsp;`*` `as` ImportedBinding</pre></code></div><div class="sec-scripts-and-modules definitions"><b>NamedImports</b><br><code><pre>NamedImports :<br>&emsp;`{` `}`<br>&emsp;`{` ImportsList `}`<br>&emsp;`{` ImportsList `,` `}`</pre></code></div><div class="sec-scripts-and-modules definitions"><b>FromClause</b><br><code><pre>FromClause :<br>&emsp;`from` ModuleSpecifier</pre></code></div><div class="sec-scripts-and-modules definitions"><b>ImportsList</b><br><code><pre>ImportsList :<br>&emsp;ImportSpecifier<br>&emsp;ImportsList `,` ImportSpecifier</pre></code></div><div class="sec-scripts-and-modules definitions"><b>ImportSpecifier</b><br><code><pre>ImportSpecifier :<br>&emsp;ImportedBinding<br>&emsp;IdentifierName `as` ImportedBinding</pre></code></div><div class="sec-scripts-and-modules definitions"><b>ModuleSpecifier</b><br><code><pre>ModuleSpecifier :<br>&emsp;StringLiteral</pre></code></div><div class="sec-scripts-and-modules definitions"><b>ImportedBinding</b><br><code><pre>ImportedBinding :<br>&emsp;BindingIdentifier[~Yield, ~Await]</pre></code></div><div class="sec-scripts-and-modules definitions"><b>ExportDeclaration</b><br><code><pre>ExportDeclaration :<br>&emsp;`export` `*` FromClause `;`<br>&emsp;`export` ExportClause FromClause `;`<br>&emsp;`export` ExportClause `;`<br>&emsp;`export` VariableStatement[~Yield, ~Await]<br>&emsp;`export` Declaration[~Yield, ~Await]<br>&emsp;`export` `default` HoistableDeclaration[~Yield, ~Await, +Default]<br>&emsp;`export` `default` ClassDeclaration[~Yield, ~Await, +Default]<br>&emsp;`export` `default` [lookahead &lt;! {`function`, `async` [no |LineTerminator| here] `function`, `class`}] AssignmentExpression[+In, ~Yield, ~Await] `;`</pre></code><code><pre>ExportDeclaration :<br>&emsp;`export` `*` FromClause `;`<br>&emsp;`export` ExportClause FromClause `;`<br>&emsp;`export` ExportClause `;`</pre></code><code><pre>ExportDeclaration :<br>&emsp;`export` ExportClause FromClause `;`<br>&emsp;`export` `*` FromClause `;`</pre></code><code><pre>ExportDeclaration : `export` `default` HoistableDeclaration</pre></code><code><pre>ExportDeclaration : `export` ExportClause FromClause `;`</pre></code><code><pre>ExportDeclaration :<br>&emsp;`export` `*` FromClause `;`<br>&emsp;`export` ExportClause FromClause `;`<br>&emsp;`export` ExportClause `;`<br>&emsp;`export` `default` AssignmentExpression `;`</pre></code><code><pre>ExportDeclaration :<br>&emsp;`export` `*` FromClause `;`<br>&emsp;`export` ExportClause FromClause `;`<br>&emsp;`export` ExportClause `;`<br>&emsp;`export` VariableStatement</pre></code><code><pre>ExportDeclaration : `export` `*` FromClause `;`</pre></code><code><pre>ExportDeclaration :<br>&emsp;`export` ExportClause `;`<br>&emsp;`export` VariableStatement<br>&emsp;`export` Declaration<br>&emsp;`export` `default` HoistableDeclaration<br>&emsp;`export` `default` ClassDeclaration<br>&emsp;`export` `default` AssignmentExpression `;`</pre></code></div><div class="sec-scripts-and-modules definitions"><b>ExportClause</b><br><code><pre>ExportClause :<br>&emsp;`{` `}`<br>&emsp;`{` ExportsList `}`<br>&emsp;`{` ExportsList `,` `}`</pre></code></div><div class="sec-scripts-and-modules definitions"><b>ExportsList</b><br><code><pre>ExportsList :<br>&emsp;ExportSpecifier<br>&emsp;ExportsList `,` ExportSpecifier</pre></code></div><div class="sec-scripts-and-modules definitions"><b>ExportSpecifier</b><br><code><pre>ExportSpecifier :<br>&emsp;IdentifierName<br>&emsp;IdentifierName `as` IdentifierName</pre></code></div><div class="sec-number-conversions definitions"><b>StringNumericLiteral</b><br><code><pre>StringNumericLiteral :::<br>&emsp;<i>StrWhiteSpace?</i><br>&emsp;<i>StrWhiteSpace?</i> StrNumericLiteral <i>StrWhiteSpace?</i></pre></code></div><div class="sec-number-conversions definitions"><b>StrWhiteSpace</b><br><code><pre>StrWhiteSpace :::<br>&emsp;StrWhiteSpaceChar <i>StrWhiteSpace?</i></pre></code></div><div class="sec-number-conversions definitions"><b>StrWhiteSpaceChar</b><br><code><pre>StrWhiteSpaceChar :::<br>&emsp;WhiteSpace<br>&emsp;LineTerminator</pre></code></div><div class="sec-number-conversions definitions"><b>StrNumericLiteral</b><br><code><pre>StrNumericLiteral :::<br>&emsp;StrDecimalLiteral<br>&emsp;BinaryIntegerLiteral<br>&emsp;OctalIntegerLiteral<br>&emsp;HexIntegerLiteral</pre></code></div><div class="sec-number-conversions definitions"><b>StrDecimalLiteral</b><br><code><pre>StrDecimalLiteral :::<br>&emsp;StrUnsignedDecimalLiteral<br>&emsp;`+` StrUnsignedDecimalLiteral<br>&emsp;`-` StrUnsignedDecimalLiteral</pre></code></div><div class="sec-number-conversions definitions"><b>StrUnsignedDecimalLiteral</b><br><code><pre>StrUnsignedDecimalLiteral :::<br>&emsp;`Infinity`<br>&emsp;DecimalDigits `.` <i>DecimalDigits?</i> <i>ExponentPart?</i><br>&emsp;`.` DecimalDigits <i>ExponentPart?</i><br>&emsp;DecimalDigits <i>ExponentPart?</i></pre></code></div><div class="sec-number-conversions definitions"><b>DecimalDigits</b><br><code><pre>DecimalDigits ::<br>&emsp;DecimalDigit<br>&emsp;DecimalDigits DecimalDigit</pre></code></div><div class="sec-number-conversions definitions"><b>DecimalDigit</b><br><code><pre>DecimalDigit :: one of<br>&emsp;`0` `1` `2` `3` `4` `5` `6` `7` `8` `9`</pre></code></div><div class="sec-number-conversions definitions"><b>ExponentPart</b><br><code><pre>ExponentPart ::<br>&emsp;ExponentIndicator SignedInteger</pre></code></div><div class="sec-number-conversions definitions"><b>ExponentIndicator</b><br><code><pre>ExponentIndicator :: one of<br>&emsp;`e` `E`</pre></code></div><div class="sec-number-conversions definitions"><b>SignedInteger</b><br><code><pre>SignedInteger ::<br>&emsp;DecimalDigits<br>&emsp;`+` DecimalDigits<br>&emsp;`-` DecimalDigits</pre></code></div><div class="sec-number-conversions definitions"><b>HexIntegerLiteral</b><br><code><pre>HexIntegerLiteral ::<br>&emsp;`0x` HexDigits<br>&emsp;`0X` HexDigits</pre></code></div><div class="sec-number-conversions definitions"><b>HexDigit</b><br><code><pre>HexDigit :: one of<br>&emsp;`0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`</pre></code><p>All grammar symbols not explicitly defined by the |StringNumericLiteral| grammar have the definitions used in the <emu-xref href="#sec-literals-numeric-literals">Lexical Grammar for numeric literals</emu-xref>.</p></div><div class="sec-universal-resource-identifier-character-classes definitions"><b>uri</b><br><code><pre>uri :::<br>&emsp;<i>uriCharacters?</i></pre></code></div><div class="sec-universal-resource-identifier-character-classes definitions"><b>uriCharacters</b><br><code><pre>uriCharacters :::<br>&emsp;uriCharacter <i>uriCharacters?</i></pre></code></div><div class="sec-universal-resource-identifier-character-classes definitions"><b>uriCharacter</b><br><code><pre>uriCharacter :::<br>&emsp;uriReserved<br>&emsp;uriUnescaped<br>&emsp;uriEscaped</pre></code></div><div class="sec-universal-resource-identifier-character-classes definitions"><b>uriReserved</b><br><code><pre>uriReserved ::: one of<br>&emsp;`;` `/` `?` `:` `@` `&amp;` `=` `+` `$` `,`</pre></code></div><div class="sec-universal-resource-identifier-character-classes definitions"><b>uriUnescaped</b><br><code><pre>uriUnescaped :::<br>&emsp;uriAlpha<br>&emsp;DecimalDigit<br>&emsp;uriMark</pre></code></div><div class="sec-universal-resource-identifier-character-classes definitions"><b>uriEscaped</b><br><code><pre>uriEscaped :::<br>&emsp;`%` HexDigit HexDigit</pre></code></div><div class="sec-universal-resource-identifier-character-classes definitions"><b>uriAlpha</b><br><code><pre>uriAlpha ::: one of<br>&emsp;`a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`<br>&emsp;`A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`</pre></code></div><div class="sec-universal-resource-identifier-character-classes definitions"><b>uriMark</b><br><code><pre>uriMark ::: one of<br>&emsp;`-` `_` `.` `!` `~` `*` `'` `(` `)`</pre></code></div><div class="sec-regular-expressions definitions"><b>Pattern</b><br><code><pre>Pattern[U, N] ::<br>&emsp;Disjunction[?U, ?N]</pre></code></div><div class="sec-regular-expressions definitions"><b>Disjunction</b><br><code><pre>Disjunction[U, N] ::<br>&emsp;Alternative[?U, ?N]<br>&emsp;Alternative[?U, ?N] `|` Disjunction[?U, ?N]</pre></code></div><div class="sec-regular-expressions definitions"><b>Alternative</b><br><code><pre>Alternative[U, N] ::<br>&emsp;[empty]<br>&emsp;Alternative[?U, ?N] Term[?U, ?N]</pre></code></div><div class="sec-regular-expressions definitions"><b>Term</b><br><code><pre>Term[U, N] ::<br>&emsp;Assertion[?U, ?N]<br>&emsp;Atom[?U, ?N]<br>&emsp;Atom[?U, ?N] Quantifier</pre></code><code><pre>Term[U, N] ::<br>&emsp;[+U] Assertion[+U, ?N]<br>&emsp;[+U] Atom[+U, ?N]<br>&emsp;[+U] Atom[+U, ?N] Quantifier<br>&emsp;[~U] QuantifiableAssertion[?N] Quantifier<br>&emsp;[~U] Assertion[~U, ?N]<br>&emsp;[~U] ExtendedAtom[?N] Quantifier<br>&emsp;[~U] ExtendedAtom[?N]</pre></code></div><div class="sec-regular-expressions definitions"><b>Assertion</b><br><code><pre>Assertion[U, N] ::<br>&emsp;`^`<br>&emsp;`$`<br>&emsp;`\` `b`<br>&emsp;`\` `B`<br>&emsp;`(` `?` `=` Disjunction[?U, ?N] `)`<br>&emsp;`(` `?` `!` Disjunction[?U, ?N] `)`<br>&emsp;`(` `?` `&lt;=` Disjunction[?U, ?N] `)`<br>&emsp;`(` `?` `&lt;!` Disjunction[?U, ?N] `)`</pre></code><code><pre>Assertion[U, N] ::<br>&emsp;`^`<br>&emsp;`$`<br>&emsp;`\` `b`<br>&emsp;`\` `B`<br>&emsp;[+U] `(` `?` `=` Disjunction[+U, ?N] `)`<br>&emsp;[+U] `(` `?` `!` Disjunction[+U, ?N] `)`<br>&emsp;[~U] QuantifiableAssertion[?N]</pre></code></div><div class="sec-regular-expressions definitions"><b>Quantifier</b><br><code><pre>Quantifier ::<br>&emsp;QuantifierPrefix<br>&emsp;QuantifierPrefix `?`</pre></code></div><div class="sec-regular-expressions definitions"><b>QuantifierPrefix</b><br><code><pre>QuantifierPrefix ::<br>&emsp;`*`<br>&emsp;`+`<br>&emsp;`?`<br>&emsp;`{` DecimalDigits `}`<br>&emsp;`{` DecimalDigits `,` `}`<br>&emsp;`{` DecimalDigits `,` DecimalDigits `}`</pre></code></div><div class="sec-regular-expressions definitions"><b>Atom</b><br><code><pre>Atom[U, N] ::<br>&emsp;PatternCharacter<br>&emsp;`.`<br>&emsp;`\` AtomEscape[?U, ?N]<br>&emsp;CharacterClass[?U]<br>&emsp;`(` GroupSpecifier[?U] Disjunction[?U, ?N] `)`<br>&emsp;`(` `?` `:` Disjunction[?U, ?N] `)`</pre></code></div><div class="sec-regular-expressions definitions"><b>SyntaxCharacter</b><br><code><pre>SyntaxCharacter :: one of<br>&emsp;`^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `]` `{` `}` `|`</pre></code></div><div class="sec-regular-expressions definitions"><b>PatternCharacter</b><br><code><pre>PatternCharacter ::<br>&emsp;SourceCharacter but not SyntaxCharacter</pre></code></div><div class="sec-regular-expressions definitions"><b>AtomEscape</b><br><code><pre>AtomEscape[U, N] ::<br>&emsp;DecimalEscape<br>&emsp;CharacterClassEscape[?U]<br>&emsp;CharacterEscape[?U]<br>&emsp;[+N] `k` GroupName[?U]</pre></code><code><pre>AtomEscape[U, N] ::<br>&emsp;[+U] DecimalEscape<br>&emsp;[~U] DecimalEscape [> but only if the CapturingGroupNumber of |DecimalEscape| is &lt;= _NcapturingParens_]<br>&emsp;CharacterClassEscape[?U]<br>&emsp;CharacterEscape[~U, ?N]<br>&emsp;[+N] `k` GroupName[?U]</pre></code></div><div class="sec-regular-expressions definitions"><b>CharacterEscape</b><br><code><pre>CharacterEscape[U] ::<br>&emsp;ControlEscape<br>&emsp;`c` ControlLetter<br>&emsp;`0` [lookahead &lt;! DecimalDigit]<br>&emsp;HexEscapeSequence<br>&emsp;RegExpUnicodeEscapeSequence[?U]<br>&emsp;IdentityEscape[?U]</pre></code><code><pre>CharacterEscape ::<br>&emsp;ControlEscape<br>&emsp;`c` ControlLetter<br>&emsp;`0` [lookahead &lt;! DecimalDigit]<br>&emsp;HexEscapeSequence<br>&emsp;RegExpUnicodeEscapeSequence<br>&emsp;IdentityEscape</pre></code><code><pre>CharacterEscape[U, N] ::<br>&emsp;ControlEscape<br>&emsp;`c` ControlLetter<br>&emsp;`0` [lookahead &lt;! DecimalDigit]<br>&emsp;HexEscapeSequence<br>&emsp;RegExpUnicodeEscapeSequence[?U]<br>&emsp;[~U] LegacyOctalEscapeSequence<br>&emsp;IdentityEscape[?U, ?N]</pre></code></div><div class="sec-regular-expressions definitions"><b>ControlEscape</b><br><code><pre>ControlEscape :: one of<br>&emsp;`f` `n` `r` `t` `v`</pre></code></div><div class="sec-regular-expressions definitions"><b>ControlLetter</b><br><code><pre>ControlLetter :: one of<br>&emsp;`a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`<br>&emsp;`A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`</pre></code></div><div class="sec-regular-expressions definitions"><b>RegExpUnicodeEscapeSequence</b><br><code><pre>RegExpUnicodeEscapeSequence[U] ::<br>&emsp;[+U] `u` LeadSurrogate `\u` TrailSurrogate<br>&emsp;[+U] `u` LeadSurrogate<br>&emsp;[+U] `u` TrailSurrogate<br>&emsp;[+U] `u` NonSurrogate<br>&emsp;[~U] `u` Hex4Digits<br>&emsp;[+U] `u{` CodePoint `}`</pre></code><p>Each `\\u` |TrailSurrogate| for which the choice of associated `u` |LeadSurrogate| is ambiguous shall be associated with the nearest possible `u` |LeadSurrogate| that would otherwise have no corresponding `\\u` |TrailSurrogate|.</p></div><div class="sec-regular-expressions definitions"><b>LeadSurrogate</b><br><code><pre>LeadSurrogate ::<br>&emsp;Hex4Digits [> but only if the SV of |Hex4Digits| is in the inclusive range 0xD800 to 0xDBFF]</pre></code><code><pre>LeadSurrogate :: Hex4Digits</pre></code></div><div class="sec-regular-expressions definitions"><b>TrailSurrogate</b><br><code><pre>TrailSurrogate ::<br>&emsp;Hex4Digits [> but only if the SV of |Hex4Digits| is in the inclusive range 0xDC00 to 0xDFFF]</pre></code><code><pre>TrailSurrogate :: Hex4Digits</pre></code></div><div class="sec-regular-expressions definitions"><b>NonSurrogate</b><br><code><pre>NonSurrogate ::<br>&emsp;Hex4Digits [> but only if the SV of |Hex4Digits| is not in the inclusive range 0xD800 to 0xDFFF]</pre></code><code><pre>NonSurrogate :: Hex4Digits</pre></code></div><div class="sec-regular-expressions definitions"><b>IdentityEscape</b><br><code><pre>IdentityEscape[U] ::<br>&emsp;[+U] SyntaxCharacter<br>&emsp;[+U] `/`<br>&emsp;[~U] SourceCharacter but not UnicodeIDContinue</pre></code><code><pre>IdentityEscape[U, N] ::<br>&emsp;[+U] SyntaxCharacter<br>&emsp;[+U] `/`<br>&emsp;[~U] SourceCharacterIdentityEscape[?N]</pre></code></div><div class="sec-regular-expressions definitions"><b>DecimalEscape</b><br><code><pre>DecimalEscape ::<br>&emsp;NonZeroDigit <i>DecimalDigits?</i> [lookahead &lt;! DecimalDigit]</pre></code></div><div class="sec-regular-expressions definitions"><b>CharacterClassEscape</b><br><code><pre>CharacterClassEscape[U] ::<br>&emsp;`d`<br>&emsp;`D`<br>&emsp;`s`<br>&emsp;`S`<br>&emsp;`w`<br>&emsp;`W`<br>&emsp;[+U] `p{` UnicodePropertyValueExpression `}`<br>&emsp;[+U] `P{` UnicodePropertyValueExpression `}`</pre></code></div><div class="sec-regular-expressions definitions"><b>CharacterClass</b><br><code><pre>CharacterClass[U] ::<br>&emsp;`[` [lookahead &lt;! {`^`}] ClassRanges[?U] `]`<br>&emsp;`[` `^` ClassRanges[?U] `]`</pre></code></div><div class="sec-regular-expressions definitions"><b>ClassRanges</b><br><code><pre>ClassRanges[U] ::<br>&emsp;[empty]<br>&emsp;NonemptyClassRanges[?U]</pre></code></div><div class="sec-regular-expressions definitions"><b>NonemptyClassRanges</b><br><code><pre>NonemptyClassRanges[U] ::<br>&emsp;ClassAtom[?U]<br>&emsp;ClassAtom[?U] NonemptyClassRangesNoDash[?U]<br>&emsp;ClassAtom[?U] `-` ClassAtom[?U] ClassRanges[?U]</pre></code></div><div class="sec-regular-expressions definitions"><b>NonemptyClassRangesNoDash</b><br><code><pre>NonemptyClassRangesNoDash[U] ::<br>&emsp;ClassAtom[?U]<br>&emsp;ClassAtomNoDash[?U] NonemptyClassRangesNoDash[?U]<br>&emsp;ClassAtomNoDash[?U] `-` ClassAtom[?U] ClassRanges[?U]</pre></code></div><div class="sec-regular-expressions definitions"><b>ClassAtom</b><br><code><pre>ClassAtom[U] ::<br>&emsp;`-`<br>&emsp;ClassAtomNoDash[?U]</pre></code><code><pre>ClassAtom :: `-`</pre></code></div><div class="sec-regular-expressions definitions"><b>ClassAtomNoDash</b><br><code><pre>ClassAtomNoDash[U] ::<br>&emsp;SourceCharacter but not one of `\` or `]` or `-`<br>&emsp;`\` ClassEscape[?U]</pre></code><code><pre>ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`</pre></code><code><pre>ClassAtomNoDash[U, N] ::<br>&emsp;SourceCharacter but not one of `\` or `]` or `-`<br>&emsp;`\` ClassEscape[?U, ?N]<br>&emsp;`\` [lookahead == `c`]</pre></code><code><pre>ClassAtomNoDash :: `\` [lookahead == `c`]</pre></code></div><div class="sec-regular-expressions definitions"><b>ClassEscape</b><br><code><pre>ClassEscape[U] ::<br>&emsp;`d`<br>&emsp;`D`<br>&emsp;`s`<br>&emsp;`S`<br>&emsp;`w`<br>&emsp;`W`<br>&emsp;[+U] `p{` UnicodePropertyValueExpression `}`<br>&emsp;[+U] `P{` UnicodePropertyValueExpression `}`</pre></code><code><pre>ClassEscape :: `b`</pre></code><code><pre>ClassEscape :: `-`</pre></code><code><pre>ClassEscape :: CharacterClassEscape</pre></code><code><pre>ClassEscape[U, N] ::<br>&emsp;`b`<br>&emsp;[+U] `-`<br>&emsp;[~U] `c` ClassControlLetter<br>&emsp;CharacterClassEscape[?U]<br>&emsp;CharacterEscape[?U, ?N]</pre></code></div>
</div><script>
{let tmp=document.querySelectorAll("#selector input");
for(let i in tmp)if(tmp[i].type==="checkbox"&&tmp[i].id.substr(0,7)==="select-")tmp[i].onchange=function(){
    let elem="sec-"+this.id.substr(7),visible=this.checked,nodes=document.querySelectorAll("div ."+elem);
    for(let i=0;i<nodes.length;i++){nodes[i].style.display=visible?null:"none";}
};
let links=document.querySelectorAll("#selector input + a");
for(let i=0;i<links.length;i++){let name=links[i].previousElementSibling.id;links[i].onclick=function(){
    for(let j=0;j<links.length;j++){let prev=links[j].previousElementSibling;prev.checked=prev.id===name;prev.onchange()}
}}}
</script></body></html>